//----------------------------------------------------------------
//      _____
//     /     \
//    /____   \____
//   / \===\   \==/
//  /___\===\___\/  AVNET
//       \======/
//        \====/
//---------------------------------------------------------------
//
// This design is the property of Avnet.  Publication of this
// design is not authorized without written consent from Avnet.
//
// Please direct any questions to:  technical.support@avnet.com
//
// Disclaimer:
//    Avnet, Inc. makes no warranty for the use of this code or design.
//    This code is provided  "As Is". Avnet, Inc assumes no responsibility for
//    any errors, which may appear in this code, nor does it make a commitment
//    to update the information contained herein. Avnet, Inc specifically
//    disclaims any implied warranties of fitness for a particular purpose.
//                     Copyright(c) 2012 Avnet, Inc.
//                             All rights reserved.
//
//----------------------------------------------------------------
//
// Create Date:         Feb 11, 2012
// Design Name:         Video Image Processing Pipeline
// Module Name:         video_ipipe.c
// Project Name:        FMC-IMAGEON
// Target Devices:      Zynq-7000
// Avnet Boards:        FMC-IMAGEON
//
// Tool versions:       Vivado 2013.2
//
// Description:         Video Image Processing Pipeline using:
//                      - Defect Pixel Correction (DPC)
//                      - Color Filter Array Interpolation (CFA)
//                      - Image Statistics (STATS)
//                      - Image Enhancement (ENHANCE)
//                      - Color Correction (CCM)
//                      - Gamma Correction (GAMMA)
//
// Dependencies:
//
// Revision:            Feb 11, 2012: 1.00 Initial version
//                      Jul 20, 2012: 1.01 Update code for single CCM
//                      Dec 15, 2012: 1.03 Updated to use 14.4 cores
//                                         and Xilinx tools
//                      Aug 16, 2013: 1.04 Updated for new Image Enhancement core
//
//----------------------------------------------------------------

#include "video_ipipe.h"

#include "xparameters.h"

#include "sleep.h"
#include "os.h"

//#include "xintc.h"
//XIntc intc_dev;

//static int printnow=0;
//Xint32 irq_cnt = 0;

#if defined(XPAR_STATS_0_BASEADDR)
STATS_Zone_Delineator zones;
STATS_Zone_Delineator zones_v;
#endif

//static float gamma_eq_str = GAMMA_EQ_STR_INIT;
//static Xuint32  default_spc_age= 0;

#if defined(XPAR_GAMMA_0_BASEADDR)

#if GAMMA_DATA_WIDTH == 8
static Xuint16 gamma_tables[5 * 256] = {
// gamma = linear
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
		38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
		56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
		74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,
		92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
		108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
		122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135,
		136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
		150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
		164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
		178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
		192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,
		206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
		220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233,
		234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,
		248, 249, 250, 251, 252, 253, 254, 255,
// gamma = 1/1.6
		0, 21, 28, 34, 39, 43, 46, 50, 53, 56, 59, 61, 64, 66, 68, 70, 72, 74,
		76, 78, 80, 82, 84, 85, 87, 89, 90, 92, 93, 95, 96, 98, 99, 101, 102,
		103, 105, 106, 107, 109, 110, 111, 112, 114, 115, 116, 117, 118, 119,
		120, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
		135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 144, 145, 146, 147,
		148, 149, 150, 151, 151, 152, 153, 154, 155, 156, 156, 157, 158, 159,
		160, 160, 161, 162, 163, 164, 164, 165, 166, 167, 167, 168, 169, 170,
		170, 171, 172, 173, 173, 174, 175, 175, 176, 177, 178, 178, 179, 180,
		180, 181, 182, 182, 183, 184, 184, 185, 186, 186, 187, 188, 188, 189,
		190, 190, 191, 192, 192, 193, 194, 194, 195, 195, 196, 197, 197, 198,
		199, 199, 200, 200, 201, 202, 202, 203, 203, 204, 205, 205, 206, 206,
		207, 207, 208, 209, 209, 210, 210, 211, 212, 212, 213, 213, 214, 214,
		215, 215, 216, 217, 217, 218, 218, 219, 219, 220, 220, 221, 221, 222,
		223, 223, 224, 224, 225, 225, 226, 226, 227, 227, 228, 228, 229, 229,
		230, 230, 231, 231, 232, 232, 233, 233, 234, 234, 235, 235, 236, 236,
		237, 237, 238, 238, 239, 239, 240, 240, 241, 241, 242, 242, 243, 243,
		244, 244, 245, 245, 246, 246, 247, 247, 248, 248, 249, 249, 249, 250,
		250, 251, 251, 252, 252, 253, 253, 254, 254, 255, 255,
// gamma = 1/2.2
		0, 8, 12, 16, 19, 22, 24, 27, 29, 32, 34, 36, 38, 40, 42, 43, 45, 47,
		49, 50, 52, 54, 55, 57, 58, 60, 61, 63, 64, 66, 67, 68, 70, 71, 72, 74,
		75, 76, 78, 79, 80, 81, 83, 84, 85, 86, 87, 89, 90, 91, 92, 93, 94, 96,
		97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 112,
		113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 125,
		126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 138,
		139, 140, 141, 142, 143, 144, 145, 146, 146, 147, 148, 149, 150, 151,
		152, 152, 153, 154, 155, 156, 157, 158, 158, 159, 160, 161, 162, 162,
		163, 164, 165, 166, 167, 167, 168, 169, 170, 171, 171, 172, 173, 174,
		175, 175, 176, 177, 178, 178, 179, 180, 181, 181, 182, 183, 184, 185,
		185, 186, 187, 188, 188, 189, 190, 191, 191, 192, 193, 194, 194, 195,
		196, 196, 197, 198, 199, 199, 200, 201, 202, 202, 203, 204, 204, 205,
		206, 207, 207, 208, 209, 209, 210, 211, 211, 212, 213, 214, 214, 215,
		216, 216, 217, 218, 218, 219, 220, 220, 221, 222, 222, 223, 224, 225,
		225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234,
		234, 235, 236, 236, 237, 238, 238, 239, 240, 240, 241, 242, 242, 243,
		244, 244, 245, 246, 246, 247, 247, 248, 249, 249, 250, 251, 251, 252,
		252, 253, 254, 254, 255,
// gamma = 1.6
		0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5,
		6, 6, 7, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15,
		15, 16, 16, 17, 18, 18, 19, 19, 20, 21, 21, 22, 23, 23, 24, 25, 25, 26,
		27, 27, 28, 29, 29, 30, 31, 31, 32, 33, 34, 34, 35, 36, 37, 38, 38, 39,
		40, 41, 42, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 53, 54,
		55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 64, 65, 66, 67, 68, 69, 70, 71,
		72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 83, 84, 85, 86, 87, 88, 89, 90,
		91, 92, 93, 94, 95, 97, 98, 99, 100, 101, 102, 103, 104, 106, 107, 108,
		109, 110, 111, 113, 114, 115, 116, 117, 119, 120, 121, 122, 123, 125,
		126, 127, 128, 130, 131, 132, 133, 135, 136, 137, 138, 140, 141, 142,
		143, 145, 146, 147, 149, 150, 151, 153, 154, 155, 157, 158, 159, 161,
		162, 163, 165, 166, 167, 169, 170, 171, 173, 174, 176, 177, 178, 180,
		181, 183, 184, 185, 187, 188, 190, 191, 193, 194, 196, 197, 198, 200,
		201, 203, 204, 206, 207, 209, 210, 212, 213, 215, 216, 218, 219, 221,
		222, 224, 225, 227, 228, 230, 231, 233, 235, 236, 238, 239, 241, 242,
		244, 245, 247, 249, 250, 252, 253, 255,
// gamma = 2.2
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6,
		6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13,
		14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23,
		23, 24, 25, 25, 26, 26, 27, 28, 28, 29, 30, 30, 31, 32, 33, 33, 34, 35,
		35, 36, 37, 38, 39, 39, 40, 41, 42, 43, 43, 44, 45, 46, 47, 48, 49, 49,
		50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
		68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 81, 82, 83, 84, 85, 87, 88,
		89, 90, 91, 93, 94, 95, 97, 98, 99, 100, 102, 103, 105, 106, 107, 109,
		110, 111, 113, 114, 116, 117, 119, 120, 121, 123, 124, 126, 127, 129,
		130, 132, 133, 135, 137, 138, 140, 141, 143, 145, 146, 148, 149, 151,
		153, 154, 156, 158, 159, 161, 163, 165, 166, 168, 170, 172, 173, 175,
		177, 179, 181, 182, 184, 186, 188, 190, 192, 194, 196, 197, 199, 201,
		203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229,
		231, 234, 236, 238, 240, 242, 244, 246, 248, 251, 253, 255 };
#endif // #if GAMMA_DATA_WIDTH == 8
#if GAMMA_DATA_WIDTH == 10
static Xuint16 gamma_tables[5*1024] = {
// gamma = linear
	0, 1, 2, 3, 4, 5, 6, 7,
	8, 9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39,
	40, 41, 42, 43, 44, 45, 46, 47,
	48, 49, 50, 51, 52, 53, 54, 55,
	56, 57, 58, 59, 60, 61, 62, 63,
	64, 65, 66, 67, 68, 69, 70, 71,
	72, 73, 74, 75, 76, 77, 78, 79,
	80, 81, 82, 83, 84, 85, 86, 87,
	88, 89, 90, 91, 92, 93, 94, 95,
	96, 97, 98, 99, 100, 101, 102, 103,
	104, 105, 106, 107, 108, 109, 110, 111,
	112, 113, 114, 115, 116, 117, 118, 119,
	120, 121, 122, 123, 124, 125, 126, 127,
	128, 129, 130, 131, 132, 133, 134, 135,
	136, 137, 138, 139, 140, 141, 142, 143,
	144, 145, 146, 147, 148, 149, 150, 151,
	152, 153, 154, 155, 156, 157, 158, 159,
	160, 161, 162, 163, 164, 165, 166, 167,
	168, 169, 170, 171, 172, 173, 174, 175,
	176, 177, 178, 179, 180, 181, 182, 183,
	184, 185, 186, 187, 188, 189, 190, 191,
	192, 193, 194, 195, 196, 197, 198, 199,
	200, 201, 202, 203, 204, 205, 206, 207,
	208, 209, 210, 211, 212, 213, 214, 215,
	216, 217, 218, 219, 220, 221, 222, 223,
	224, 225, 226, 227, 228, 229, 230, 231,
	232, 233, 234, 235, 236, 237, 238, 239,
	240, 241, 242, 243, 244, 245, 246, 247,
	248, 249, 250, 251, 252, 253, 254, 255,
	256, 257, 258, 259, 260, 261, 262, 263,
	264, 265, 266, 267, 268, 269, 270, 271,
	272, 273, 274, 275, 276, 277, 278, 279,
	280, 281, 282, 283, 284, 285, 286, 287,
	288, 289, 290, 291, 292, 293, 294, 295,
	296, 297, 298, 299, 300, 301, 302, 303,
	304, 305, 306, 307, 308, 309, 310, 311,
	312, 313, 314, 315, 316, 317, 318, 319,
	320, 321, 322, 323, 324, 325, 326, 327,
	328, 329, 330, 331, 332, 333, 334, 335,
	336, 337, 338, 339, 340, 341, 342, 343,
	344, 345, 346, 347, 348, 349, 350, 351,
	352, 353, 354, 355, 356, 357, 358, 359,
	360, 361, 362, 363, 364, 365, 366, 367,
	368, 369, 370, 371, 372, 373, 374, 375,
	376, 377, 378, 379, 380, 381, 382, 383,
	384, 385, 386, 387, 388, 389, 390, 391,
	392, 393, 394, 395, 396, 397, 398, 399,
	400, 401, 402, 403, 404, 405, 406, 407,
	408, 409, 410, 411, 412, 413, 414, 415,
	416, 417, 418, 419, 420, 421, 422, 423,
	424, 425, 426, 427, 428, 429, 430, 431,
	432, 433, 434, 435, 436, 437, 438, 439,
	440, 441, 442, 443, 444, 445, 446, 447,
	448, 449, 450, 451, 452, 453, 454, 455,
	456, 457, 458, 459, 460, 461, 462, 463,
	464, 465, 466, 467, 468, 469, 470, 471,
	472, 473, 474, 475, 476, 477, 478, 479,
	480, 481, 482, 483, 484, 485, 486, 487,
	488, 489, 490, 491, 492, 493, 494, 495,
	496, 497, 498, 499, 500, 501, 502, 503,
	504, 505, 506, 507, 508, 509, 510, 511,
	512, 513, 514, 515, 516, 517, 518, 519,
	520, 521, 522, 523, 524, 525, 526, 527,
	528, 529, 530, 531, 532, 533, 534, 535,
	536, 537, 538, 539, 540, 541, 542, 543,
	544, 545, 546, 547, 548, 549, 550, 551,
	552, 553, 554, 555, 556, 557, 558, 559,
	560, 561, 562, 563, 564, 565, 566, 567,
	568, 569, 570, 571, 572, 573, 574, 575,
	576, 577, 578, 579, 580, 581, 582, 583,
	584, 585, 586, 587, 588, 589, 590, 591,
	592, 593, 594, 595, 596, 597, 598, 599,
	600, 601, 602, 603, 604, 605, 606, 607,
	608, 609, 610, 611, 612, 613, 614, 615,
	616, 617, 618, 619, 620, 621, 622, 623,
	624, 625, 626, 627, 628, 629, 630, 631,
	632, 633, 634, 635, 636, 637, 638, 639,
	640, 641, 642, 643, 644, 645, 646, 647,
	648, 649, 650, 651, 652, 653, 654, 655,
	656, 657, 658, 659, 660, 661, 662, 663,
	664, 665, 666, 667, 668, 669, 670, 671,
	672, 673, 674, 675, 676, 677, 678, 679,
	680, 681, 682, 683, 684, 685, 686, 687,
	688, 689, 690, 691, 692, 693, 694, 695,
	696, 697, 698, 699, 700, 701, 702, 703,
	704, 705, 706, 707, 708, 709, 710, 711,
	712, 713, 714, 715, 716, 717, 718, 719,
	720, 721, 722, 723, 724, 725, 726, 727,
	728, 729, 730, 731, 732, 733, 734, 735,
	736, 737, 738, 739, 740, 741, 742, 743,
	744, 745, 746, 747, 748, 749, 750, 751,
	752, 753, 754, 755, 756, 757, 758, 759,
	760, 761, 762, 763, 764, 765, 766, 767,
	768, 769, 770, 771, 772, 773, 774, 775,
	776, 777, 778, 779, 780, 781, 782, 783,
	784, 785, 786, 787, 788, 789, 790, 791,
	792, 793, 794, 795, 796, 797, 798, 799,
	800, 801, 802, 803, 804, 805, 806, 807,
	808, 809, 810, 811, 812, 813, 814, 815,
	816, 817, 818, 819, 820, 821, 822, 823,
	824, 825, 826, 827, 828, 829, 830, 831,
	832, 833, 834, 835, 836, 837, 838, 839,
	840, 841, 842, 843, 844, 845, 846, 847,
	848, 849, 850, 851, 852, 853, 854, 855,
	856, 857, 858, 859, 860, 861, 862, 863,
	864, 865, 866, 867, 868, 869, 870, 871,
	872, 873, 874, 875, 876, 877, 878, 879,
	880, 881, 882, 883, 884, 885, 886, 887,
	888, 889, 890, 891, 892, 893, 894, 895,
	896, 897, 898, 899, 900, 901, 902, 903,
	904, 905, 906, 907, 908, 909, 910, 911,
	912, 913, 914, 915, 916, 917, 918, 919,
	920, 921, 922, 923, 924, 925, 926, 927,
	928, 929, 930, 931, 932, 933, 934, 935,
	936, 937, 938, 939, 940, 941, 942, 943,
	944, 945, 946, 947, 948, 949, 950, 951,
	952, 953, 954, 955, 956, 957, 958, 959,
	960, 961, 962, 963, 964, 965, 966, 967,
	968, 969, 970, 971, 972, 973, 974, 975,
	976, 977, 978, 979, 980, 981, 982, 983,
	984, 985, 986, 987, 988, 989, 990, 991,
	992, 993, 994, 995, 996, 997, 998, 999,
	1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007,
	1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015,
	1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023,
// gamma = 1/1.6
	0, 44, 60, 72, 82, 91, 99, 106,
	113, 119, 125, 130, 136, 141, 145, 150,
	155, 159, 163, 167, 171, 175, 179, 182,
	186, 189, 193, 196, 199, 203, 206, 209,
	212, 215, 218, 221, 223, 226, 229, 232,
	234, 237, 240, 242, 245, 247, 250, 252,
	255, 257, 259, 262, 264, 266, 269, 271,
	273, 275, 278, 280, 282, 284, 286, 288,
	290, 292, 294, 296, 298, 300, 302, 304,
	306, 308, 310, 312, 314, 316, 318, 319,
	321, 323, 325, 327, 328, 330, 332, 334,
	335, 337, 339, 341, 342, 344, 346, 347,
	349, 351, 352, 354, 355, 357, 359, 360,
	362, 363, 365, 367, 368, 370, 371, 373,
	374, 376, 377, 379, 380, 382, 383, 385,
	386, 388, 389, 391, 392, 393, 395, 396,
	398, 399, 401, 402, 403, 405, 406, 407,
	409, 410, 412, 413, 414, 416, 417, 418,
	420, 421, 422, 424, 425, 426, 427, 429,
	430, 431, 433, 434, 435, 436, 438, 439,
	440, 441, 443, 444, 445, 446, 448, 449,
	450, 451, 452, 454, 455, 456, 457, 458,
	460, 461, 462, 463, 464, 466, 467, 468,
	469, 470, 471, 473, 474, 475, 476, 477,
	478, 479, 480, 482, 483, 484, 485, 486,
	487, 488, 489, 490, 492, 493, 494, 495,
	496, 497, 498, 499, 500, 501, 502, 503,
	505, 506, 507, 508, 509, 510, 511, 512,
	513, 514, 515, 516, 517, 518, 519, 520,
	521, 522, 523, 524, 525, 526, 527, 528,
	529, 530, 531, 532, 533, 534, 535, 536,
	537, 538, 539, 540, 541, 542, 543, 544,
	545, 546, 547, 548, 549, 550, 551, 552,
	553, 554, 555, 556, 556, 557, 558, 559,
	560, 561, 562, 563, 564, 565, 566, 567,
	568, 569, 570, 570, 571, 572, 573, 574,
	575, 576, 577, 578, 579, 579, 580, 581,
	582, 583, 584, 585, 586, 587, 588, 588,
	589, 590, 591, 592, 593, 594, 595, 595,
	596, 597, 598, 599, 600, 601, 601, 602,
	603, 604, 605, 606, 607, 607, 608, 609,
	610, 611, 612, 613, 613, 614, 615, 616,
	617, 618, 618, 619, 620, 621, 622, 623,
	623, 624, 625, 626, 627, 627, 628, 629,
	630, 631, 632, 632, 633, 634, 635, 636,
	636, 637, 638, 639, 640, 640, 641, 642,
	643, 644, 644, 645, 646, 647, 647, 648,
	649, 650, 651, 651, 652, 653, 654, 655,
	655, 656, 657, 658, 658, 659, 660, 661,
	661, 662, 663, 664, 665, 665, 666, 667,
	668, 668, 669, 670, 671, 671, 672, 673,
	674, 674, 675, 676, 677, 677, 678, 679,
	680, 680, 681, 682, 683, 683, 684, 685,
	685, 686, 687, 688, 688, 689, 690, 691,
	691, 692, 693, 694, 694, 695, 696, 696,
	697, 698, 699, 699, 700, 701, 701, 702,
	703, 704, 704, 705, 706, 706, 707, 708,
	709, 709, 710, 711, 711, 712, 713, 713,
	714, 715, 716, 716, 717, 718, 718, 719,
	720, 720, 721, 722, 723, 723, 724, 725,
	725, 726, 727, 727, 728, 729, 729, 730,
	731, 731, 732, 733, 733, 734, 735, 735,
	736, 737, 737, 738, 739, 740, 740, 741,
	742, 742, 743, 744, 744, 745, 746, 746,
	747, 748, 748, 749, 749, 750, 751, 751,
	752, 753, 753, 754, 755, 755, 756, 757,
	757, 758, 759, 759, 760, 761, 761, 762,
	763, 763, 764, 765, 765, 766, 766, 767,
	768, 768, 769, 770, 770, 771, 772, 772,
	773, 773, 774, 775, 775, 776, 777, 777,
	778, 779, 779, 780, 780, 781, 782, 782,
	783, 784, 784, 785, 785, 786, 787, 787,
	788, 789, 789, 790, 790, 791, 792, 792,
	793, 793, 794, 795, 795, 796, 797, 797,
	798, 798, 799, 800, 800, 801, 801, 802,
	803, 803, 804, 805, 805, 806, 806, 807,
	808, 808, 809, 809, 810, 811, 811, 812,
	812, 813, 814, 814, 815, 815, 816, 817,
	817, 818, 818, 819, 819, 820, 821, 821,
	822, 822, 823, 824, 824, 825, 825, 826,
	827, 827, 828, 828, 829, 830, 830, 831,
	831, 832, 832, 833, 834, 834, 835, 835,
	836, 836, 837, 838, 838, 839, 839, 840,
	841, 841, 842, 842, 843, 843, 844, 845,
	845, 846, 846, 847, 847, 848, 849, 849,
	850, 850, 851, 851, 852, 853, 853, 854,
	854, 855, 855, 856, 856, 857, 858, 858,
	859, 859, 860, 860, 861, 861, 862, 863,
	863, 864, 864, 865, 865, 866, 867, 867,
	868, 868, 869, 869, 870, 870, 871, 871,
	872, 873, 873, 874, 874, 875, 875, 876,
	876, 877, 878, 878, 879, 879, 880, 880,
	881, 881, 882, 882, 883, 884, 884, 885,
	885, 886, 886, 887, 887, 888, 888, 889,
	889, 890, 891, 891, 892, 892, 893, 893,
	894, 894, 895, 895, 896, 896, 897, 897,
	898, 899, 899, 900, 900, 901, 901, 902,
	902, 903, 903, 904, 904, 905, 905, 906,
	906, 907, 908, 908, 909, 909, 910, 910,
	911, 911, 912, 912, 913, 913, 914, 914,
	915, 915, 916, 916, 917, 917, 918, 918,
	919, 919, 920, 921, 921, 922, 922, 923,
	923, 924, 924, 925, 925, 926, 926, 927,
	927, 928, 928, 929, 929, 930, 930, 931,
	931, 932, 932, 933, 933, 934, 934, 935,
	935, 936, 936, 937, 937, 938, 938, 939,
	939, 940, 940, 941, 941, 942, 942, 943,
	943, 944, 944, 945, 945, 946, 946, 947,
	947, 948, 948, 949, 949, 950, 950, 951,
	951, 952, 952, 953, 953, 954, 954, 955,
	955, 956, 956, 957, 957, 958, 958, 959,
	959, 960, 960, 961, 961, 962, 962, 963,
	963, 964, 964, 965, 965, 966, 966, 967,
	967, 968, 968, 969, 969, 970, 970, 970,
	971, 971, 972, 972, 973, 973, 974, 974,
	975, 975, 976, 976, 977, 977, 978, 978,
	979, 979, 980, 980, 981, 981, 982, 982,
	982, 983, 983, 984, 984, 985, 985, 986,
	986, 987, 987, 988, 988, 989, 989, 990,
	990, 991, 991, 992, 992, 992, 993, 993,
	994, 994, 995, 995, 996, 996, 997, 997,
	998, 998, 999, 999, 999, 1000, 1000, 1001,
	1001, 1002, 1002, 1003, 1003, 1004, 1004, 1005,
	1005, 1006, 1006, 1006, 1007, 1007, 1008, 1008,
	1009, 1009, 1010, 1010, 1011, 1011, 1012, 1012,
	1012, 1013, 1013, 1014, 1014, 1015, 1015, 1016,
	1016, 1017, 1017, 1018, 1018, 1018, 1019, 1019,
	1020, 1020, 1021, 1021, 1022, 1022, 1023, 1023,
// gamma = 1/2.2
	0, 13, 21, 27, 32, 37, 41, 45,
	49, 53, 57, 60, 64, 67, 70, 73,
	76, 79, 82, 85, 87, 90, 93, 95,
	98, 101, 103, 106, 108, 110, 113, 115,
	117, 120, 122, 124, 126, 128, 131, 133,
	135, 137, 139, 141, 143, 145, 147, 149,
	151, 153, 155, 157, 159, 161, 163, 165,
	166, 168, 170, 172, 174, 176, 177, 179,
	181, 183, 184, 186, 188, 190, 191, 193,
	195, 196, 198, 200, 201, 203, 205, 206,
	208, 210, 211, 213, 214, 216, 218, 219,
	221, 222, 224, 225, 227, 229, 230, 232,
	233, 235, 236, 238, 239, 241, 242, 244,
	245, 247, 248, 249, 251, 252, 254, 255,
	257, 258, 260, 261, 262, 264, 265, 267,
	268, 269, 271, 272, 274, 275, 276, 278,
	279, 280, 282, 283, 284, 286, 287, 289,
	290, 291, 292, 294, 295, 296, 298, 299,
	300, 302, 303, 304, 306, 307, 308, 309,
	311, 312, 313, 315, 316, 317, 318, 320,
	321, 322, 323, 325, 326, 327, 328, 330,
	331, 332, 333, 334, 336, 337, 338, 339,
	341, 342, 343, 344, 345, 347, 348, 349,
	350, 351, 352, 354, 355, 356, 357, 358,
	360, 361, 362, 363, 364, 365, 367, 368,
	369, 370, 371, 372, 373, 375, 376, 377,
	378, 379, 380, 381, 383, 384, 385, 386,
	387, 388, 389, 390, 391, 393, 394, 395,
	396, 397, 398, 399, 400, 401, 403, 404,
	405, 406, 407, 408, 409, 410, 411, 412,
	413, 414, 416, 417, 418, 419, 420, 421,
	422, 423, 424, 425, 426, 427, 428, 429,
	430, 431, 432, 434, 435, 436, 437, 438,
	439, 440, 441, 442, 443, 444, 445, 446,
	447, 448, 449, 450, 451, 452, 453, 454,
	455, 456, 457, 458, 459, 460, 461, 462,
	463, 464, 465, 466, 467, 468, 469, 470,
	471, 472, 473, 474, 475, 476, 477, 478,
	479, 480, 481, 482, 483, 484, 485, 486,
	487, 488, 489, 490, 491, 492, 493, 494,
	495, 496, 497, 498, 499, 500, 501, 502,
	502, 503, 504, 505, 506, 507, 508, 509,
	510, 511, 512, 513, 514, 515, 516, 517,
	518, 519, 520, 520, 521, 522, 523, 524,
	525, 526, 527, 528, 529, 530, 531, 532,
	533, 534, 534, 535, 536, 537, 538, 539,
	540, 541, 542, 543, 544, 545, 545, 546,
	547, 548, 549, 550, 551, 552, 553, 554,
	555, 555, 556, 557, 558, 559, 560, 561,
	562, 563, 563, 564, 565, 566, 567, 568,
	569, 570, 571, 572, 572, 573, 574, 575,
	576, 577, 578, 579, 579, 580, 581, 582,
	583, 584, 585, 586, 586, 587, 588, 589,
	590, 591, 592, 593, 593, 594, 595, 596,
	597, 598, 599, 599, 600, 601, 602, 603,
	604, 605, 605, 606, 607, 608, 609, 610,
	611, 611, 612, 613, 614, 615, 616, 617,
	617, 618, 619, 620, 621, 622, 622, 623,
	624, 625, 626, 627, 627, 628, 629, 630,
	631, 632, 633, 633, 634, 635, 636, 637,
	637, 638, 639, 640, 641, 642, 642, 643,
	644, 645, 646, 647, 647, 648, 649, 650,
	651, 652, 652, 653, 654, 655, 656, 656,
	657, 658, 659, 660, 660, 661, 662, 663,
	664, 665, 665, 666, 667, 668, 669, 669,
	670, 671, 672, 673, 673, 674, 675, 676,
	677, 677, 678, 679, 680, 681, 681, 682,
	683, 684, 685, 685, 686, 687, 688, 689,
	689, 690, 691, 692, 693, 693, 694, 695,
	696, 696, 697, 698, 699, 700, 700, 701,
	702, 703, 704, 704, 705, 706, 707, 707,
	708, 709, 710, 711, 711, 712, 713, 714,
	714, 715, 716, 717, 718, 718, 719, 720,
	721, 721, 722, 723, 724, 724, 725, 726,
	727, 728, 728, 729, 730, 731, 731, 732,
	733, 734, 734, 735, 736, 737, 737, 738,
	739, 740, 741, 741, 742, 743, 744, 744,
	745, 746, 747, 747, 748, 749, 750, 750,
	751, 752, 753, 753, 754, 755, 756, 756,
	757, 758, 759, 759, 760, 761, 762, 762,
	763, 764, 765, 765, 766, 767, 768, 768,
	769, 770, 770, 771, 772, 773, 773, 774,
	775, 776, 776, 777, 778, 779, 779, 780,
	781, 782, 782, 783, 784, 784, 785, 786,
	787, 787, 788, 789, 790, 790, 791, 792,
	793, 793, 794, 795, 795, 796, 797, 798,
	798, 799, 800, 801, 801, 802, 803, 803,
	804, 805, 806, 806, 807, 808, 808, 809,
	810, 811, 811, 812, 813, 813, 814, 815,
	816, 816, 817, 818, 819, 819, 820, 821,
	821, 822, 823, 823, 824, 825, 826, 826,
	827, 828, 828, 829, 830, 831, 831, 832,
	833, 833, 834, 835, 836, 836, 837, 838,
	838, 839, 840, 840, 841, 842, 843, 843,
	844, 845, 845, 846, 847, 847, 848, 849,
	850, 850, 851, 852, 852, 853, 854, 854,
	855, 856, 857, 857, 858, 859, 859, 860,
	861, 861, 862, 863, 863, 864, 865, 866,
	866, 867, 868, 868, 869, 870, 870, 871,
	872, 872, 873, 874, 875, 875, 876, 877,
	877, 878, 879, 879, 880, 881, 881, 882,
	883, 883, 884, 885, 885, 886, 887, 888,
	888, 889, 890, 890, 891, 892, 892, 893,
	894, 894, 895, 896, 896, 897, 898, 898,
	899, 900, 900, 901, 902, 902, 903, 904,
	904, 905, 906, 906, 907, 908, 908, 909,
	910, 910, 911, 912, 912, 913, 914, 914,
	915, 916, 916, 917, 918, 918, 919, 920,
	920, 921, 922, 922, 923, 924, 924, 925,
	926, 926, 927, 928, 928, 929, 930, 930,
	931, 932, 932, 933, 934, 934, 935, 936,
	936, 937, 938, 938, 939, 940, 940, 941,
	942, 942, 943, 944, 944, 945, 946, 946,
	947, 948, 948, 949, 950, 950, 951, 951,
	952, 953, 953, 954, 955, 955, 956, 957,
	957, 958, 959, 959, 960, 961, 961, 962,
	963, 963, 964, 964, 965, 966, 966, 967,
	968, 968, 969, 970, 970, 971, 972, 972,
	973, 974, 974, 975, 975, 976, 977, 977,
	978, 979, 979, 980, 981, 981, 982, 983,
	983, 984, 984, 985, 986, 986, 987, 988,
	988, 989, 990, 990, 991, 991, 992, 993,
	993, 994, 995, 995, 996, 997, 997, 998,
	998, 999, 1000, 1000, 1001, 1002, 1002, 1003,
	1004, 1004, 1005, 1005, 1006, 1007, 1007, 1008,
	1009, 1009, 1010, 1010, 1011, 1012, 1012, 1013,
	1014, 1014, 1015, 1015, 1016, 1017, 1017, 1018,
	1019, 1019, 1020, 1020, 1021, 1022, 1022, 1023,
// gamma = 1.6
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 2, 2, 2, 2, 2, 2,
	3, 3, 3, 3, 3, 3, 4, 4,
	4, 4, 4, 5, 5, 5, 5, 5,
	6, 6, 6, 6, 7, 7, 7, 7,
	8, 8, 8, 8, 9, 9, 9, 10,
	10, 10, 10, 11, 11, 11, 12, 12,
	12, 12, 13, 13, 13, 14, 14, 14,
	15, 15, 15, 16, 16, 16, 17, 17,
	17, 18, 18, 18, 19, 19, 19, 20,
	20, 21, 21, 21, 22, 22, 22, 23,
	23, 24, 24, 24, 25, 25, 26, 26,
	26, 27, 27, 28, 28, 28, 29, 29,
	30, 30, 31, 31, 31, 32, 32, 33,
	33, 34, 34, 35, 35, 35, 36, 36,
	37, 37, 38, 38, 39, 39, 40, 40,
	41, 41, 41, 42, 42, 43, 43, 44,
	44, 45, 45, 46, 46, 47, 47, 48,
	48, 49, 49, 50, 50, 51, 52, 52,
	53, 53, 54, 54, 55, 55, 56, 56,
	57, 57, 58, 58, 59, 60, 60, 61,
	61, 62, 62, 63, 63, 64, 65, 65,
	66, 66, 67, 67, 68, 69, 69, 70,
	70, 71, 72, 72, 73, 73, 74, 75,
	75, 76, 76, 77, 78, 78, 79, 79,
	80, 81, 81, 82, 82, 83, 84, 84,
	85, 86, 86, 87, 87, 88, 89, 89,
	90, 91, 91, 92, 93, 93, 94, 95,
	95, 96, 97, 97, 98, 99, 99, 100,
	101, 101, 102, 103, 103, 104, 105, 105,
	106, 107, 107, 108, 109, 109, 110, 111,
	111, 112, 113, 114, 114, 115, 116, 116,
	117, 118, 119, 119, 120, 121, 121, 122,
	123, 124, 124, 125, 126, 126, 127, 128,
	129, 129, 130, 131, 132, 132, 133, 134,
	135, 135, 136, 137, 138, 138, 139, 140,
	141, 141, 142, 143, 144, 144, 145, 146,
	147, 148, 148, 149, 150, 151, 151, 152,
	153, 154, 155, 155, 156, 157, 158, 159,
	159, 160, 161, 162, 163, 163, 164, 165,
	166, 167, 167, 168, 169, 170, 171, 171,
	172, 173, 174, 175, 176, 176, 177, 178,
	179, 180, 181, 181, 182, 183, 184, 185,
	186, 186, 187, 188, 189, 190, 191, 192,
	192, 193, 194, 195, 196, 197, 198, 198,
	199, 200, 201, 202, 203, 204, 204, 205,
	206, 207, 208, 209, 210, 211, 212, 212,
	213, 214, 215, 216, 217, 218, 219, 220,
	220, 221, 222, 223, 224, 225, 226, 227,
	228, 229, 230, 230, 231, 232, 233, 234,
	235, 236, 237, 238, 239, 240, 241, 242,
	242, 243, 244, 245, 246, 247, 248, 249,
	250, 251, 252, 253, 254, 255, 256, 257,
	258, 258, 259, 260, 261, 262, 263, 264,
	265, 266, 267, 268, 269, 270, 271, 272,
	273, 274, 275, 276, 277, 278, 279, 280,
	281, 282, 283, 284, 285, 286, 287, 288,
	289, 290, 291, 292, 293, 294, 295, 296,
	297, 298, 299, 300, 301, 302, 303, 304,
	305, 306, 307, 308, 309, 310, 311, 312,
	313, 314, 315, 316, 317, 318, 319, 320,
	321, 322, 323, 324, 325, 326, 327, 329,
	330, 331, 332, 333, 334, 335, 336, 337,
	338, 339, 340, 341, 342, 343, 344, 345,
	346, 348, 349, 350, 351, 352, 353, 354,
	355, 356, 357, 358, 359, 360, 362, 363,
	364, 365, 366, 367, 368, 369, 370, 371,
	372, 374, 375, 376, 377, 378, 379, 380,
	381, 382, 383, 385, 386, 387, 388, 389,
	390, 391, 392, 393, 395, 396, 397, 398,
	399, 400, 401, 402, 404, 405, 406, 407,
	408, 409, 410, 411, 413, 414, 415, 416,
	417, 418, 419, 421, 422, 423, 424, 425,
	426, 428, 429, 430, 431, 432, 433, 434,
	436, 437, 438, 439, 440, 441, 443, 444,
	445, 446, 447, 448, 450, 451, 452, 453,
	454, 456, 457, 458, 459, 460, 461, 463,
	464, 465, 466, 467, 469, 470, 471, 472,
	473, 475, 476, 477, 478, 479, 481, 482,
	483, 484, 485, 487, 488, 489, 490, 492,
	493, 494, 495, 496, 498, 499, 500, 501,
	502, 504, 505, 506, 507, 509, 510, 511,
	512, 514, 515, 516, 517, 519, 520, 521,
	522, 523, 525, 526, 527, 528, 530, 531,
	532, 533, 535, 536, 537, 538, 540, 541,
	542, 544, 545, 546, 547, 549, 550, 551,
	552, 554, 555, 556, 557, 559, 560, 561,
	563, 564, 565, 566, 568, 569, 570, 572,
	573, 574, 575, 577, 578, 579, 581, 582,
	583, 584, 586, 587, 588, 590, 591, 592,
	594, 595, 596, 598, 599, 600, 601, 603,
	604, 605, 607, 608, 609, 611, 612, 613,
	615, 616, 617, 619, 620, 621, 623, 624,
	625, 627, 628, 629, 631, 632, 633, 635,
	636, 637, 639, 640, 641, 643, 644, 645,
	647, 648, 649, 651, 652, 653, 655, 656,
	657, 659, 660, 662, 663, 664, 666, 667,
	668, 670, 671, 672, 674, 675, 677, 678,
	679, 681, 682, 683, 685, 686, 688, 689,
	690, 692, 693, 694, 696, 697, 699, 700,
	701, 703, 704, 706, 707, 708, 710, 711,
	712, 714, 715, 717, 718, 719, 721, 722,
	724, 725, 727, 728, 729, 731, 732, 734,
	735, 736, 738, 739, 741, 742, 743, 745,
	746, 748, 749, 751, 752, 753, 755, 756,
	758, 759, 761, 762, 763, 765, 766, 768,
	769, 771, 772, 774, 775, 776, 778, 779,
	781, 782, 784, 785, 787, 788, 789, 791,
	792, 794, 795, 797, 798, 800, 801, 803,
	804, 805, 807, 808, 810, 811, 813, 814,
	816, 817, 819, 820, 822, 823, 825, 826,
	828, 829, 830, 832, 833, 835, 836, 838,
	839, 841, 842, 844, 845, 847, 848, 850,
	851, 853, 854, 856, 857, 859, 860, 862,
	863, 865, 866, 868, 869, 871, 872, 874,
	875, 877, 878, 880, 881, 883, 884, 886,
	887, 889, 890, 892, 893, 895, 897, 898,
	900, 901, 903, 904, 906, 907, 909, 910,
	912, 913, 915, 916, 918, 919, 921, 923,
	924, 926, 927, 929, 930, 932, 933, 935,
	936, 938, 940, 941, 943, 944, 946, 947,
	949, 950, 952, 954, 955, 957, 958, 960,
	961, 963, 964, 966, 968, 969, 971, 972,
	974, 975, 977, 979, 980, 982, 983, 985,
	986, 988, 990, 991, 993, 994, 996, 998,
	999, 1001, 1002, 1004, 1005, 1007, 1009, 1010,
	1012, 1013, 1015, 1017, 1018, 1020, 1021, 1023,
// gamma = 2.2
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 2, 2, 2,
	2, 2, 2, 2, 2, 2, 2, 2,
	2, 2, 2, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 4, 4,
	4, 4, 4, 4, 4, 4, 4, 5,
	5, 5, 5, 5, 5, 5, 5, 5,
	6, 6, 6, 6, 6, 6, 6, 7,
	7, 7, 7, 7, 7, 7, 8, 8,
	8, 8, 8, 8, 9, 9, 9, 9,
	9, 9, 10, 10, 10, 10, 10, 10,
	11, 11, 11, 11, 11, 11, 12, 12,
	12, 12, 12, 13, 13, 13, 13, 13,
	14, 14, 14, 14, 15, 15, 15, 15,
	15, 16, 16, 16, 16, 17, 17, 17,
	17, 18, 18, 18, 18, 18, 19, 19,
	19, 19, 20, 20, 20, 21, 21, 21,
	21, 22, 22, 22, 22, 23, 23, 23,
	23, 24, 24, 24, 25, 25, 25, 25,
	26, 26, 26, 27, 27, 27, 28, 28,
	28, 29, 29, 29, 29, 30, 30, 30,
	31, 31, 31, 32, 32, 32, 33, 33,
	33, 34, 34, 34, 35, 35, 35, 36,
	36, 37, 37, 37, 38, 38, 38, 39,
	39, 39, 40, 40, 41, 41, 41, 42,
	42, 43, 43, 43, 44, 44, 44, 45,
	45, 46, 46, 46, 47, 47, 48, 48,
	49, 49, 49, 50, 50, 51, 51, 52,
	52, 52, 53, 53, 54, 54, 55, 55,
	55, 56, 56, 57, 57, 58, 58, 59,
	59, 60, 60, 61, 61, 61, 62, 62,
	63, 63, 64, 64, 65, 65, 66, 66,
	67, 67, 68, 68, 69, 69, 70, 70,
	71, 71, 72, 72, 73, 73, 74, 75,
	75, 76, 76, 77, 77, 78, 78, 79,
	79, 80, 80, 81, 82, 82, 83, 83,
	84, 84, 85, 85, 86, 87, 87, 88,
	88, 89, 89, 90, 91, 91, 92, 92,
	93, 94, 94, 95, 95, 96, 97, 97,
	98, 98, 99, 100, 100, 101, 102, 102,
	103, 103, 104, 105, 105, 106, 107, 107,
	108, 109, 109, 110, 110, 111, 112, 112,
	113, 114, 114, 115, 116, 116, 117, 118,
	118, 119, 120, 121, 121, 122, 123, 123,
	124, 125, 125, 126, 127, 127, 128, 129,
	130, 130, 131, 132, 132, 133, 134, 135,
	135, 136, 137, 138, 138, 139, 140, 141,
	141, 142, 143, 144, 144, 145, 146, 147,
	147, 148, 149, 150, 150, 151, 152, 153,
	154, 154, 155, 156, 157, 157, 158, 159,
	160, 161, 161, 162, 163, 164, 165, 166,
	166, 167, 168, 169, 170, 170, 171, 172,
	173, 174, 175, 175, 176, 177, 178, 179,
	180, 181, 181, 182, 183, 184, 185, 186,
	187, 187, 188, 189, 190, 191, 192, 193,
	194, 194, 195, 196, 197, 198, 199, 200,
	201, 202, 203, 203, 204, 205, 206, 207,
	208, 209, 210, 211, 212, 213, 214, 215,
	216, 216, 217, 218, 219, 220, 221, 222,
	223, 224, 225, 226, 227, 228, 229, 230,
	231, 232, 233, 234, 235, 236, 237, 238,
	239, 240, 241, 242, 243, 244, 245, 246,
	247, 248, 249, 250, 251, 252, 253, 254,
	255, 256, 257, 258, 259, 260, 261, 262,
	263, 264, 265, 266, 267, 269, 270, 271,
	272, 273, 274, 275, 276, 277, 278, 279,
	280, 281, 283, 284, 285, 286, 287, 288,
	289, 290, 291, 292, 294, 295, 296, 297,
	298, 299, 300, 301, 303, 304, 305, 306,
	307, 308, 309, 311, 312, 313, 314, 315,
	316, 317, 319, 320, 321, 322, 323, 324,
	326, 327, 328, 329, 330, 332, 333, 334,
	335, 336, 338, 339, 340, 341, 342, 344,
	345, 346, 347, 348, 350, 351, 352, 353,
	355, 356, 357, 358, 360, 361, 362, 363,
	365, 366, 367, 368, 370, 371, 372, 373,
	375, 376, 377, 378, 380, 381, 382, 384,
	385, 386, 387, 389, 390, 391, 393, 394,
	395, 397, 398, 399, 401, 402, 403, 405,
	406, 407, 409, 410, 411, 413, 414, 415,
	417, 418, 419, 421, 422, 423, 425, 426,
	427, 429, 430, 432, 433, 434, 436, 437,
	438, 440, 441, 443, 444, 445, 447, 448,
	450, 451, 452, 454, 455, 457, 458, 459,
	461, 462, 464, 465, 467, 468, 469, 471,
	472, 474, 475, 477, 478, 480, 481, 483,
	484, 485, 487, 488, 490, 491, 493, 494,
	496, 497, 499, 500, 502, 503, 505, 506,
	508, 509, 511, 512, 514, 515, 517, 518,
	520, 521, 523, 524, 526, 527, 529, 531,
	532, 534, 535, 537, 538, 540, 541, 543,
	544, 546, 548, 549, 551, 552, 554, 555,
	557, 559, 560, 562, 563, 565, 567, 568,
	570, 571, 573, 575, 576, 578, 579, 581,
	583, 584, 586, 587, 589, 591, 592, 594,
	596, 597, 599, 601, 602, 604, 605, 607,
	609, 610, 612, 614, 615, 617, 619, 620,
	622, 624, 625, 627, 629, 631, 632, 634,
	636, 637, 639, 641, 642, 644, 646, 648,
	649, 651, 653, 654, 656, 658, 660, 661,
	663, 665, 667, 668, 670, 672, 674, 675,
	677, 679, 681, 682, 684, 686, 688, 689,
	691, 693, 695, 697, 698, 700, 702, 704,
	705, 707, 709, 711, 713, 714, 716, 718,
	720, 722, 724, 725, 727, 729, 731, 733,
	735, 736, 738, 740, 742, 744, 746, 747,
	749, 751, 753, 755, 757, 759, 761, 762,
	764, 766, 768, 770, 772, 774, 776, 777,
	779, 781, 783, 785, 787, 789, 791, 793,
	795, 797, 798, 800, 802, 804, 806, 808,
	810, 812, 814, 816, 818, 820, 822, 824,
	826, 828, 830, 831, 833, 835, 837, 839,
	841, 843, 845, 847, 849, 851, 853, 855,
	857, 859, 861, 863, 865, 867, 869, 871,
	873, 875, 877, 879, 881, 883, 885, 887,
	890, 892, 894, 896, 898, 900, 902, 904,
	906, 908, 910, 912, 914, 916, 918, 920,
	922, 925, 927, 929, 931, 933, 935, 937,
	939, 941, 943, 945, 948, 950, 952, 954,
	956, 958, 960, 962, 965, 967, 969, 971,
	973, 975, 977, 980, 982, 984, 986, 988,
	990, 992, 995, 997, 999, 1001, 1003, 1006,
	1008, 1010, 1012, 1014, 1016, 1019, 1021, 1023
};
#endif // #if GAMMA_DATA_WIDTH == 10
unsigned char gamma_names[5][24] = { "Linear Table           ",
		"Compression Table 1/1.6", "Compression Table 1/2.2",
		"Expansion Table 1.6    ", "Expansion Table 2.2    " };

#endif // #if defined(XPAR_GAMMA_0_BASEADDR)
CCM_Coefficient CCM_IDENTITY =
		{ 32768, 0, 0, 0, 32768, 0, 0, 0, 32768, 0, 0, 0 };

CCM_Coefficient CCM_RGB_BYPASS = { 32768, 0, 0, 0, 32768, 0, 0, 0, 32768, 0, 0,
		0 };

CCM_Coefficient CCM_RGB_DAY = { 39987, 4797, -12907, -11588, 53568, -15443,
		-1789, -18452, 62486, -3, -2, 3 };

CCM_Coefficient CCM_RGB_CWF = { 56966, -10736, -15715, -13849, 44434, -3634,
		-5530, -13959, 82167, 0, -3, 6 };

CCM_Coefficient CCM_RGB_U30 = { 41891, -7668, -8338, -14108, 61880, -23266,
		-1599, -23597, 106117, -5, -1, 11 };

CCM_Coefficient CCM_RGB_INC = { 28327, 26712, -25522, -30600, 130744, -62567,
		-16566, 21673, 73290, -8, 1, 13 };

Xuint32 STATS_ZOOM2_DAY[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135, 240, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 113, 524, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0 };

Xuint32 STATS_ZOOM2_CWF[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 207, 186, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 2, 6, 36, 494, 79, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0 };

Xuint32 STATS_ZOOM2_U30[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 2, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 581, 362, 14, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0 };

Xuint32 STATS_ZOOM2_INC[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 5, 31, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 320, 73, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 456, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0 };

Xuint8 stats_readout_indexes[] = { 97, 98, 99, 101, 102, 113, 114, 115, 116,
		117, 118, 119, 131, 132, 133, 145, 146, 147, 148, 149, 161, 162, 163,
		176, 177, 178, 192, 193, 208 };
Xuint8 day_nonzero_indexes[] = { 101, 102, 117, 118, 119 };
Xuint8 cwf_nonzero_indexes[] = { 97, 98, 99, 113, 114, 115, 116, 117, 118 };
Xuint8 u30_nonzero_indexes[] = { 131, 132, 133, 145, 146, 147, 148, 149 };
Xuint8 inc_nonzero_indexes[] = { 161, 162, 163, 176, 177, 178, 192, 193, 208 };

Xuint32 wb_mask[16][16] =
		{ { 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0 }, { 0, 0, 0, 0, 0,
				0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0 }, { 0, 0, 0, 0, 0, 0, 0, 1, 1,
				1, 1, 1, 1, 1, 1, 1 }, { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
				1, 1, 1 }, { 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }, {
				0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }, { 0, 0, 0, 1,
				1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 }, { 0, 0, 1, 1, 1, 1, 1, 1,
				1, 1, 1, 1, 1, 1, 1, 0 }, { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
				1, 1, 0, 0 },
				{ 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 }, { 0, 1, 1,
						1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 }, { 0, 1, 1, 1,
						1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }, { 0, 1, 1, 1, 1,
						1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 1, 1, 1, 1,
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0,
						0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0,
						0, 0, 0, 0, 0, 0, 0, 0 } };

/* Set Bayer filter phase
 * Returns 0 if phase was set successfully, otherwise not
 */
Xint32 vipp_bayer(video_ipipe_t *pContext, Xuint32 phase) {
	Xuint32 BaseAddress = pContext->uBaseAddr_CFA;

	CFA_RegUpdateDisable(BaseAddress);
	CFA_WriteReg(BaseAddress, CFA_BAYER_PHASE, phase);
	CFA_RegUpdateEnable(BaseAddress);

	return 0;
}

/******************************************************************************
 * This function configures the CFA LogiCore with new parameters.
 *
 * @param    cfa_params contains a vector of CFA parameters.
 *
 * @param    num_params contains the number of elements in the cfa_param[] vector.
 *
 * @return   None.
 *
 * @note     None.
 *
 ******************************************************************************/
typedef struct {
	Xint8 *sm_name;
	Xuint32 addr;
	Xuint32 val;
} IVK_CG_CFA_PARAMS;

void vipp_cfa_config(video_ipipe_t *pContext, IVK_CG_CFA_PARAMS cfa_params[],
		Xuint32 num_params) {
	Xuint32 BaseAddress = pContext->uBaseAddr_CFA;
	Xint32 i;
	Xuint32 cfa_value;
	Xint32 retval = 1;

	// Step 0 ) Disable Reset
#ifdef DEBUG
	OS_PRINTF( "Step 0) Disable Reset\r\n" );
#endif
	cfa_value = 0x00000000; // SW_RESET=0
	CFA_WriteReg(BaseAddress, CFA_RST_AUTORESET, cfa_value);
#ifdef DEBUG
	OS_PRINTF("  CFA Param[%s] = 0x%x\r\n", "cfa_reset", cfa_value);
#endif

	// Step 1 ) Enable CFA, Disable Register Update
#ifdef DEBUG
	OS_PRINTF( "Step 1) Enable CFA Logicore\r\n" );
#endif
	cfa_value = 0x00000001; // WR_DONE=0 | SW_ENABLE=1
	CFA_WriteReg(BaseAddress, CFA_CONTROL, cfa_value);
#ifdef DEBUG
	OS_PRINTF("  CFA Param[%s] = 0x%x\r\n", "cfa_control", cfa_value);
#endif

	usleep(100);

	// Step 2 ) Write new configuration registers
#ifdef DEBUG
	OS_PRINTF( "Step 2) Write new CFA parameters\r\n" );
#endif
	for (i = 0; i < num_params; i++) {
		CFA_WriteReg(BaseAddress, cfa_params[i].addr,
				(const unsigned )cfa_params[i].val);
#ifdef DEBUG
		OS_PRINTF("  CFA Param[%s] = 0x%x\r\n", cfa_params[i].sm_name, cfa_params[i].val);
#endif
	}

	// Step 3 ) Enable CFA, Enable Register Update
#ifdef DEBUG
	OS_PRINTF( "Step 3) Enable Register Update\r\n" );
#endif
	cfa_value = 0x00000003; // WR_DONE=1 | SW_ENABLE=1
	CFA_WriteReg(BaseAddress, CFA_CONTROL, cfa_value);
#ifdef DEBUG
	OS_PRINTF("  CFA Param[%s] = 0x%x\r\n", "cfa_control", cfa_value);
#endif

	usleep(100);

	// Step 4 ) Enable CFA, Disable Register Update
#ifdef DEBUG
	OS_PRINTF( "Step 4) Disable Register Upate\r\n" );
#endif
	cfa_value = 0x00000001; // WR_DONE=0 | SW_ENABLE=1
	CFA_WriteReg(BaseAddress, CFA_CONTROL, cfa_value);
#ifdef DEBUG
	OS_PRINTF("  CFA Param[%s] = 0x%x\r\n", "cfa_control", cfa_value);
#endif

	return;
}

/***************************************************************************/
// Color Filter Array Interpolation Register Reading Example
// This function provides an example of how to read the current configuration
// settings of the CFA core.
/***************************************************************************/
void vipp_cfa_status(video_ipipe_t *pContext) {
	Xuint32 BaseAddress = pContext->uBaseAddr_CFA;
	Xuint32 status, reg_val;

	OS_PRINTF("Color Filter Array Core Configuration:\r\n");
	OS_PRINTF(" Enable Bit: %1lu\r\n",
			CFA_ReadReg(BaseAddress, CFA_CONTROL) & CFA_CTL_EN_MASK);
	OS_PRINTF(" Register Update Bit: %1lu\r\n",
			(CFA_ReadReg(BaseAddress, CFA_CONTROL) & CFA_CTL_RUE_MASK) >> 1);
	OS_PRINTF(" Reset Bit: %1lu\r\n",
			CFA_ReadReg(BaseAddress, CFA_CONTROL) & CFA_RST_RESET);
	status = CFA_ReadReg(BaseAddress, CFA_STATUS);
	OS_PRINTF(" CFA Status: %08x \r\n", (unsigned int) status);
	OS_PRINTF(" Core Version:   %1lu.%1lu\r\n", (status & 0x78) >> 3,
			(status & 0x07));
	reg_val = CFA_ReadReg(BaseAddress, CFA_CONTROL );
	OS_PRINTF("CFA_CONTROL           : %8x\r\n", (unsigned int) reg_val);
	reg_val = CFA_ReadReg(BaseAddress, CFA_IRQ_EN );
	OS_PRINTF("CFA Interrupt Control : %8x\r\n", (unsigned int) reg_val);
	reg_val = (CFA_ReadReg(BaseAddress, CFA_ACTIVE_SIZE )) >> 16;
	OS_PRINTF("CFA Active Rows        : %8d\r\n", (unsigned int) reg_val);
	reg_val = (CFA_ReadReg(BaseAddress, CFA_ACTIVE_SIZE ) & 0x0000FFFF);
	OS_PRINTF("CFA Active Cols        : %8d\r\n", (unsigned int) reg_val);
	reg_val = CFA_ReadReg(BaseAddress, CFA_BAYER_PHASE );
	OS_PRINTF("CFA_BAYER_PHASE       : %8u\r\n", (unsigned int) reg_val);
}

/***************************************************************************/
// Defect Pixel Correction Register Reading Example
// This function provides an example of how to read the current configuration
// settings of the DPC core.
/***************************************************************************/
void vipp_dpc_status(video_ipipe_t *pContext) {
	Xuint32 BaseAddress = pContext->uBaseAddr_DPC;
	Xuint32 status, reg_val;

	OS_PRINTF("Defect Pixel Correction Core Configuration:\r\n");
	OS_PRINTF(" Enable Bit: %1lu\r\n",
			DPC_ReadReg(BaseAddress, DPC_CONTROL) & CFA_CTL_EN_MASK);
	OS_PRINTF(" Register Update Bit: %1lu\r\n",
			(DPC_ReadReg(BaseAddress, DPC_CONTROL) & DPC_CTL_RUE_MASK) >> 1);
	status = (DPC_ReadReg(BaseAddress, DPC_CONTROL) >> 31);
	OS_PRINTF(" Reset Bit: %1u\r\n", (unsigned int) status);
	status = DPC_ReadReg(BaseAddress, DPC_STATUS);
	OS_PRINTF(" DPC Status: %08x \r\n", (unsigned int) status);
	reg_val = DPC_ReadReg(BaseAddress, DPC_CONTROL );
	OS_PRINTF("DPC_CONTROL             : 0x%08X\r\n", (unsigned int) reg_val);
	reg_val = DPC_ReadReg(BaseAddress, DPC_STATUS );
	OS_PRINTF("DPC_STATUS              : 0x%08X\r\n", (unsigned int) reg_val);
	reg_val = DPC_ReadReg(BaseAddress, DPC_THRESH_TEMPORAL_VAR );
	OS_PRINTF("DPC_THRESH_TEMPORAL_VAR : %u\r\n", (unsigned int) reg_val);
	reg_val = DPC_ReadReg(BaseAddress, DPC_THRESH_SPATIAL_VAR );
	OS_PRINTF("DPC_THRESH_SPATIAL_VAR  : %u\r\n", (unsigned int) reg_val);
	reg_val = DPC_ReadReg(BaseAddress, DPC_THRESH_PIXEL_AGE );
	OS_PRINTF("DPC_THRESH_PIXEL_AGE    : %u\r\n", (unsigned int) reg_val);
	reg_val = DPC_ReadReg(BaseAddress, DPC_NUM_CANDIDATES );
	OS_PRINTF("DPC_NUM_CANDIDATES      : %u\r\n", (unsigned int) reg_val);
	reg_val = DPC_ReadReg(BaseAddress, DPC_NUM_DEFECTIVE );
	OS_PRINTF("DPC_NUM_DEFECTIVE       : %u\r\n", (unsigned int) reg_val);
}

/***************************************************************************/
// Defective Pixel Correction Register Update Example
//  This function provides an example of the process used to update
//  the threshold registers in the DPC core.
//  In most video systems, it is expected that this process would be executed
//  in response to an interrupt connected to the VBlank video timing signal
//  or a timeout signal associated with a watchdog timer.
/***************************************************************************/
void vipp_dpc_config(video_ipipe_t *pContext, Xuint32 enable,
		Xuint32 thresh_temporal_var, Xuint32 thresh_spatial_var,
		Xuint32 thres_pixel_age) {
	Xuint32 BaseAddress = pContext->uBaseAddr_DPC;

	if (enable) {
		//Enable the DPC software enable
		DPC_Enable(BaseAddress);

		//Disable register updates.
		//This is the default operating mode for the DPC core, and allows
		//registers to be updated without effecting the core's behavior.
		DPC_RegUpdateDisable(BaseAddress);

		//Set the filter strength
		DPC_WriteReg(BaseAddress, DPC_THRESH_TEMPORAL_VAR, thresh_temporal_var);
		DPC_WriteReg(BaseAddress, DPC_THRESH_SPATIAL_VAR, thresh_spatial_var);
		DPC_WriteReg(BaseAddress, DPC_THRESH_PIXEL_AGE, thres_pixel_age);

		//Enable register updates.
		//This mode will cause the coefficient and offset registers internally
		//to the DPC core to automatically be updated on the next rising-edge
		//of VBlank.
		DPC_RegUpdateEnable(BaseAddress);
	} else {
		//Disable the DPC software enable
		DPC_Disable(BaseAddress);
	}
}

void vipp_dpc_pixel_age(video_ipipe_t *pContext, Xuint32 pixel_age) {
	Xuint32 BaseAddress = pContext->uBaseAddr_DPC;

	DPC_RegUpdateDisable(BaseAddress);
	DPC_WriteReg(BaseAddress, DPC_THRESH_PIXEL_AGE, pixel_age);
	DPC_RegUpdateEnable(BaseAddress);
}

void vipp_dpc_spatial_var(video_ipipe_t *pContext, Xuint32 spatial_var) {
	Xuint32 BaseAddress = pContext->uBaseAddr_DPC;

	DPC_RegUpdateDisable(BaseAddress);
	DPC_WriteReg(BaseAddress, DPC_THRESH_SPATIAL_VAR, spatial_var);
	DPC_RegUpdateEnable(BaseAddress);
}

void vipp_dpc_temporal_var(video_ipipe_t *pContext, Xuint32 temporal_var) {
	Xuint32 BaseAddress = pContext->uBaseAddr_DPC;

	DPC_RegUpdateDisable(BaseAddress);
	DPC_WriteReg(BaseAddress, DPC_THRESH_TEMPORAL_VAR, temporal_var);
	DPC_RegUpdateEnable(BaseAddress);
}


#if defined(XPAR_ENHANCE_0_BASEADDR)
void vipp_noise(video_ipipe_t *pContext, Xuint32 noise)
{
	Xuint32 BaseAddress = pContext->uBaseAddr_ENHANCE;

	ENHANCE_RegUpdateDisable(BaseAddress);
	ENHANCE_WriteReg(BaseAddress, ENHANCE_NOISE_THRESHOLD, noise);
	ENHANCE_RegUpdateEnable(BaseAddress);
}

void vipp_enhance(video_ipipe_t *pContext, Xuint32 enhance) {
	Xuint32 BaseAddress = pContext->uBaseAddr_ENHANCE;

	ENHANCE_RegUpdateDisable(BaseAddress);
    ENHANCE_WriteReg(BaseAddress, ENHANCE_ENHANCE_STRENGTH, enhance);
	ENHANCE_RegUpdateEnable(BaseAddress);
}

void vipp_halo(video_ipipe_t *pContext, Xuint32 halo)
{
	Xuint32 BaseAddress = pContext->uBaseAddr_ENHANCE;

	ENHANCE_RegUpdateDisable(BaseAddress);
	ENHANCE_WriteReg(BaseAddress, ENHANCE_HALO_SUPRESS, halo);
	ENHANCE_RegUpdateEnable(BaseAddress);
}
#endif

#if defined(XPAR_GAMMA_0_BASEADDR)

#if GAMMA_DATA_WIDTH == 8

Xuint16 vipp_gamma_table_value(video_ipipe_t *pContext, int TABLE_ID, int addr) {
	Xuint32 BaseAddress = pContext->uBaseAddr_GAMMA;

	return (gamma_tables[(TABLE_ID << 8) + (addr & 255)]);
}

int vipp_download_gamma_table(video_ipipe_t *pContext, int GAMMA_TABLE_ID,
		int LUTS) {                              // LUTS = 1, 2, 3
	Xuint32 BaseAddress = pContext->uBaseAddr_GAMMA;
	Xuint32 addr, data;
	for (addr = 0; addr < 256 * LUTS; addr++) {
		data = vipp_gamma_table_value(BaseAddress, GAMMA_TABLE_ID, addr);
		GAMMA_WriteReg(BaseAddress, GAMMA_ADDR_DATA, (addr << 16) + data);
	}
	return 0;
}

#endif // #if GAMMA_DATA_WIDTH == 8
#if GAMMA_DATA_WIDTH == 10

Xuint16 vipp_gamma_table_value(video_ipipe_t *pContext, int TABLE_ID, int addr)
{
	Xuint32 BaseAddress = pContext->uBaseAddr_GAMMA;

	return( gamma_tables[(TABLE_ID<<10)+(addr & 1023)] );
}

int vipp_download_gamma_table(video_ipipe_t *pContext, int GAMMA_TABLE_ID, int LUTS)
{                              // LUTS = 1, 2, 3
	Xuint32 BaseAddress = pContext->uBaseAddr_GAMMA;
	Xuint32 addr, data;
	for (addr=0; addr<1024*LUTS; addr++) {
		data = vipp_gamma_table_value(BaseAddress, GAMMA_TABLE_ID, addr);
		GAMMA_WriteReg(BaseAddress, GAMMA_ADDR_DATA, (addr << 16) + data );
	}
	return 0;
}

#endif // #if GAMMA_DATA_WIDTH == 10
#endif

/*****************************************************************************/
/**
 *
 * Gets the current coefficients and offsets used in the CCM_0 core
 *
 * @param BaseAddress is the Xilinx EDK base address of the Statistics core (from xparameters.h)
 * @param coefficientPtr is a pointer to a CCM_Coefficient struct where values are stored
 *
 * @return   None
 *
 ******************************************************************************/
void vipp_ccm_getCoefficients(video_ipipe_t *pContext,
		CCM_Coefficient* coefficientPtr) {
	u32 BaseAddress = pContext->uBaseAddr_CCM;

	coefficientPtr->k11 = CCM_ReadReg(BaseAddress, CCM_K11);
	coefficientPtr->k12 = CCM_ReadReg(BaseAddress, CCM_K12);
	coefficientPtr->k13 = CCM_ReadReg(BaseAddress, CCM_K13);
	coefficientPtr->k21 = CCM_ReadReg(BaseAddress, CCM_K21);
	coefficientPtr->k22 = CCM_ReadReg(BaseAddress, CCM_K22);
	coefficientPtr->k23 = CCM_ReadReg(BaseAddress, CCM_K23);
	coefficientPtr->k31 = CCM_ReadReg(BaseAddress, CCM_K31);
	coefficientPtr->k32 = CCM_ReadReg(BaseAddress, CCM_K32);
	coefficientPtr->k33 = CCM_ReadReg(BaseAddress, CCM_K33);
	coefficientPtr->rOffset = CCM_ReadReg(BaseAddress, CCM_ROFFSET); // cb in ycc
	coefficientPtr->gOffset = CCM_ReadReg(BaseAddress, CCM_GOFFSET); // y in ycc
	coefficientPtr->bOffset = CCM_ReadReg(BaseAddress, CCM_BOFFSET); // cr in ycc

}

/*****************************************************************************/
/**
 *
 * Sets the current CCM_0 coefficients and offsets to those specified in coefficientPtr
 *
 * @param BaseAddress is the Xilinx EDK base address of the Statistics core (from xparameters.h)
 * @param coefficientPtr is a pointer to a CCM_Coefficient struct containing the values to be written into the CCM
 *
 * @return   None
 *
 ******************************************************************************/
void vipp_ccm_setCoefficients(video_ipipe_t *pContext,
		CCM_Coefficient* coefficientPtr) {
	u32 BaseAddress = pContext->uBaseAddr_CCM;

	CCM_RegUpdateDisable(BaseAddress);
	CCM_WriteReg(BaseAddress, CCM_K11, coefficientPtr->k11);
	CCM_WriteReg(BaseAddress, CCM_K12, coefficientPtr->k12);
	CCM_WriteReg(BaseAddress, CCM_K13, coefficientPtr->k13);
	CCM_WriteReg(BaseAddress, CCM_K21, coefficientPtr->k21);
	CCM_WriteReg(BaseAddress, CCM_K22, coefficientPtr->k22);
	CCM_WriteReg(BaseAddress, CCM_K23, coefficientPtr->k23);
	CCM_WriteReg(BaseAddress, CCM_K31, coefficientPtr->k31);
	CCM_WriteReg(BaseAddress, CCM_K32, coefficientPtr->k32);
	CCM_WriteReg(BaseAddress, CCM_K33, coefficientPtr->k33);
#if CCM_DATA_WIDTH == 10
	// need to scale offsets from -256,+256 range to -1024,+1024 range
	CCM_WriteReg(BaseAddress, CCM_ROFFSET, coefficientPtr->rOffset * 4);
	CCM_WriteReg(BaseAddress, CCM_GOFFSET, coefficientPtr->gOffset * 4);
	CCM_WriteReg(BaseAddress, CCM_BOFFSET, coefficientPtr->bOffset * 4);
#else
	CCM_WriteReg(BaseAddress, CCM_ROFFSET, coefficientPtr->rOffset);
	CCM_WriteReg(BaseAddress, CCM_GOFFSET, coefficientPtr->gOffset);
	CCM_WriteReg(BaseAddress, CCM_BOFFSET, coefficientPtr->bOffset);
#endif

	//usleep(500000);
	CCM_RegUpdateEnable(BaseAddress);
}

int vipp_init(video_ipipe_t *pContext) {
	int i;

	pContext->bVerbose = 0;

	OS_PRINTF("Initializing iPipe cores ...\r\n");

	CRESAMPLE_Reset(pContext->uBaseAddr_CRES);
	CRESAMPLE_ClearReset(pContext->uBaseAddr_CRES);
	CRESAMPLE_Enable(pContext->uBaseAddr_CRES);
	OS_PRINTF("Chroma Resampler done\r\n");

#if defined(XPAR_ENHANCE_0_BASEADDR)
	ENHANCE_Reset(pContext->uBaseAddr_ENHANCE);
	ENHANCE_ClearReset(pContext->uBaseAddr_ENHANCE);
	ENHANCE_Enable(pContext->uBaseAddr_ENHANCE);
	OS_PRINTF("Enhance done\r\n");
#endif

	RGB_Reset(pContext->uBaseAddr_RGBYCC);
	RGB_ClearReset(pContext->uBaseAddr_RGBYCC);
	RGB_Enable(pContext->uBaseAddr_RGBYCC);
	OS_PRINTF("RGB2YCrCb done\r\n");

#if defined(XPAR_GAMMA_0_BASEADDR)
	GAMMA_Reset(pContext->uBaseAddr_GAMMA);
	GAMMA_ClearReset(pContext->uBaseAddr_GAMMA);
	GAMMA_Enable(pContext->uBaseAddr_GAMMA);
	vipp_download_gamma_table(pContext, 0, 3);
	OS_PRINTF("Gamma done\r\n");
#endif

#if defined(XPAR_CCM_0_BASEADDR)

	CCM_Reset(pContext->uBaseAddr_CCM);
	CCM_ClearReset(pContext->uBaseAddr_CCM);
	CCM_Enable(pContext->uBaseAddr_CCM);
	vipp_ccm_setCoefficients(pContext, &CCM_IDENTITY);
	pContext->ccm_select = 0;

	OS_PRINTF("CCM done\r\n");
#endif

#if defined(XPAR_STATS_0_BASEADDR)
	// Initialize the Image Statistics core:
	STATS_Reset(pContext->uBaseAddr_STATS);
	STATS_ClearReset(pContext->uBaseAddr_STATS);
	STATS_Enable(pContext->uBaseAddr_STATS);
	Stats_ClrStatusUnset(pContext->uBaseAddr_STATS);
	Stats_ReadoutEnable(pContext->uBaseAddr_STATS);
	Stats_RegUpdateDisable(pContext->uBaseAddr_STATS);
	STATS_WriteReg(pContext->uBaseAddr_STATS, STATS_ACTIVE_SIZE, 0x04380780);
//		zones.hmax0 = 320; //zones.hmax0 = zones.hmax0/2;
//		zones.hmax1 = 640; //zones.hmax1 = zones.hmax1/2;
//		zones.hmax2 = 960; //zones.hmax2 = zones.hmax2/2;
//		zones.vmax0 = 180; //zones.vmax0 = zones.vmax0/2;
//		zones.vmax1 = 360; //zones.vmax1 = zones.vmax1/2;
//		zones.vmax2 = 540; //zones.vmax2 = zones.vmax2/2;
	zones.hmax0 = 480; //zones.hmax0 = zones.hmax0/2;
	zones.hmax1 = 960; //zones.hmax1 = zones.hmax1/2;
	zones.hmax2 = 1440; //zones.hmax2 = zones.hmax2/2;
	zones.vmax0 = 270; //zones.vmax0 = zones.vmax0/2;
	zones.vmax1 = 540; //zones.vmax1 = zones.vmax1/2;
	zones.vmax2 = 810; //zones.vmax2 = zones.vmax2/2;
	stats_set_zones(pContext->uBaseAddr_STATS, &zones);
#if STATS_DATA_WIDTH == 10
	stats_set_chrom_hist_zoom( pContext->uBaseAddr_STATS, 1 );
#else
	stats_set_chrom_hist_zoom(pContext->uBaseAddr_STATS, 2);
#endif
	Stats_RegUpdateEnable(pContext->uBaseAddr_STATS);
	OS_PRINTF("Stats done\r\n");
#endif

#if defined(XPAR_TPG_0_BASEADDR)
	TPG_Reset(pContext->uBaseAddr_TPG0);
	TPG_ClearReset(pContext->uBaseAddr_TPG0);
	TPG_Enable(pContext->uBaseAddr_TPG0);
	TPG_RegUpdateDisable(pContext->uBaseAddr_TPG0);
	TPG_WriteReg(pContext->uBaseAddr_TPG0, TPG_PATTERN_CONTROL, 0);
	TPG_RegUpdateEnable(pContext->uBaseAddr_TPG0);
	OS_PRINTF("TPG 0 done\r\n");
#endif

#if defined(XPAR_TPG_1_BASEADDR)
	TPG_Reset(pContext->uBaseAddr_TPG1);
	TPG_ClearReset(pContext->uBaseAddr_TPG1);
	TPG_Enable(pContext->uBaseAddr_TPG1);
	TPG_RegUpdateDisable(pContext->uBaseAddr_TPG1);
	TPG_WriteReg(pContext->uBaseAddr_TPG1, TPG_PATTERN_CONTROL, 0);
	TPG_RegUpdateEnable(pContext->uBaseAddr_TPG1);
	OS_PRINTF("TPG 1 done\r\n");
#endif

#if defined(XPAR_CFA_0_BASEADDR)
	CFA_Reset(pContext->uBaseAddr_CFA);
	CFA_ClearReset(pContext->uBaseAddr_CFA);
	CFA_Enable(pContext->uBaseAddr_CFA);
	vipp_bayer(pContext, 0);
	OS_PRINTF("CFA done\r\n");
#endif

#if defined(XPAR_DPC_0_BASEADDR)
	DPC_Reset(pContext->uBaseAddr_DPC);
	DPC_ClearReset(pContext->uBaseAddr_DPC);
	DPC_RegUpdateDisable(pContext->uBaseAddr_DPC);
	DPC_WriteReg(pContext->uBaseAddr_DPC, DPC_THRESH_PIXEL_AGE,
			pContext->default_spc_age);
	DPC_RegUpdateEnable(pContext->uBaseAddr_DPC);
	DPC_Enable(pContext->uBaseAddr_DPC);
#endif

#if defined(XPAR_ENHANCE_0_BASEADDR)
//	    ENHANCE_RegUpdateDisable( pContext->uBaseAddr_ENHANCE );
//	    ENHANCE_WriteReg( pContext->uBaseAddr_ENHANCE, ENHANCE_GAIN_H, 0 );
//	    ENHANCE_WriteReg( pContext->uBaseAddr_ENHANCE, ENHANCE_GAIN_V, 0 );
//	    ENHANCE_WriteReg( pContext->uBaseAddr_ENHANCE, ENHANCE_GAIN_D, 0 );
//	    ENHANCE_WriteReg( pContext->uBaseAddr_ENHANCE, ENHANCE_GAIN_LAP, 0 );
//	    ENHANCE_RegUpdateEnable( pContext->uBaseAddr_ENHANCE );
#endif

	//pContext->cc_data_valid = 0;

	OS_PRINTF("Initializing iPipe cores ... done!\r\n");

	pContext->pSensor = NULL;
	pContext->fpSensorGetGain = NULL;
	pContext->fpSensorGetExposure = NULL;
	pContext->fpSensorStepGain = NULL;
	pContext->fpSensorStepExposure = NULL;

	pContext->auto_wb_en = 0;
	pContext->auto_exp_en = 0;
	pContext->auto_gain_en = 0;
	pContext->gamma_eq_en = 0;
	pContext->target_level = 200;

	// Contrast/Brightness/Saturation controls
	pContext->contrast = 0;
	pContext->brightness = 100;
	pContext->saturation = 100;
	pContext->brightness_set = 0;
	pContext->contrast_set = 0;
	pContext->saturation_set = 0;

	// Gamma controls
	pContext->gamma_eq_str = GAMMA_EQ_STR_INIT;

	// Defective Pixel Correction
	pContext->default_spc_age = 0;

	// histogram controls
	pContext->hist_scale = 10; // 2^N
	pContext->exp_factor_under = 0.5;
	pContext->exp_factor_over = 0.5;

	pContext->stats_handler_frame_cnt = 0;
	pContext->stats_handler_awb_metric_day = 0;
	pContext->stats_handler_awb_metric_cwf = 0;
	pContext->stats_handler_awb_metric_u30 = 0;
	pContext->stats_handler_awb_metric_inc = 0;
	for (i = 0; i < STATS_HIST_DEPTH; i++) {
		pContext->stats_handler_luma_hist[i] = 0;
	}
	for (i = 0; i < STATS_HIST_DEPTH; i++) {
		pContext->stats_handler_rgb_hist[0][i] = 0;
		pContext->stats_handler_rgb_hist[1][i] = 0;
		pContext->stats_handler_rgb_hist[2][i] = 0;
	}
	for (i = 0; i < 3; i++) {
		pContext->stats_handler_rgb_saturated[i] = 0;
		pContext->stats_handler_rgb_mean[i] = 0;
	}
	for (i = 0; i < 256; i++) {
		pContext->stats_handler_chroma_hist[i] = 0;
	}
	pContext->stats_handler_luma_metric_lo = 0;
	pContext->stats_handler_luma_metric_mid = 0;
	pContext->stats_handler_luma_metric_hi = 0;
	pContext->stats_handler_exp_metric_over = 0;
	pContext->stats_handler_exp_metric_under = 0;
	pContext->stats_handler_aec_adjust_lpf = 0;
	pContext->stats_handler_aec_adjust_inc = 0;
	pContext->stats_handler_agc_adjust_lpf = 0;
	pContext->stats_handler_agc_adjust_inc = 0;

	pContext->stats_handler_active = 0;
	pContext->stats_handler_stop = 0;

#if defined(LINUX_CODE)
	pContext->stats_handler_thread_id = pthread_create(
			&(pContext->stats_handler_thread), NULL, &vipp_stats_handler,
			(void *) pContext);
	if (pContext->stats_handler_thread_id) {
		OS_PRINTF("ERROR; return code from pthread_create() is %d\n",
				pContext->stats_handler_thread_id);
		return -1;
	}
#endif

	return 0;
}

int vipp_quit(video_ipipe_t *pContext) {

	if (pContext->stats_handler_active) {
		// Request thread to stop
		pContext->stats_handler_stop = 1;
#if defined(LINUX_CODE)
		// Wait for thread to stop
		pthread_join((pContext->stats_handler_thread), NULL );
#endif
	}

	return 0;
}

void set_contrast(video_ipipe_t *pContext, Xint32 ccm[]) {
//	ccm_getCoefficients(XPAR_CCM_0_BASEADDR, &ccm);
	ccm[9] = ccm[9] + pContext->contrast;
	ccm[10] = ccm[10] + pContext->contrast;
	ccm[11] = ccm[11] + pContext->contrast;
	pContext->contrast_set = 0;
	return;
}

void set_brightness(video_ipipe_t *pContext, Xint32 ccm[]) {
	float brightness_f = 0.01f * (float) (pContext->brightness);

//	ccm_getCoefficients(XPAR_CCM_0_BASEADDR, &ccm);
	ccm[0] = (Xint32) ((float) ccm[0] * brightness_f);
	ccm[1] = (Xint32) ((float) ccm[1] * brightness_f);
	ccm[2] = (Xint32) ((float) ccm[2] * brightness_f);
	ccm[3] = (Xint32) ((float) ccm[3] * brightness_f);
	ccm[4] = (Xint32) ((float) ccm[4] * brightness_f);
	ccm[5] = (Xint32) ((float) ccm[5] * brightness_f);
	ccm[6] = (Xint32) ((float) ccm[6] * brightness_f);
	ccm[7] = (Xint32) ((float) ccm[7] * brightness_f);
	ccm[8] = (Xint32) ((float) ccm[8] * brightness_f);
	pContext->brightness_set = 0;
	return;
}

void set_saturation(video_ipipe_t *pContext, Xint32 ccm[]) {
	float saturation_f = 0.01f * (float) (pContext->saturation);
	float CCM_temp[9];

	// update saturation values
	// http://www.graficaobscura.com/matrix/index.html

	float rwgt = 0.3086f;
	float gwgt = 0.6094f;
	float bwgt = 0.0820f;

	float a = ((1.0f - saturation_f) * rwgt + saturation_f);
	float b = ((1.0f - saturation_f) * rwgt);
	float c = ((1.0f - saturation_f) * rwgt);
	float d = ((1.0f - saturation_f) * gwgt);
	float e = ((1.0f - saturation_f) * gwgt + saturation_f);
	float f = ((1.0f - saturation_f) * gwgt);
	float g = ((1.0f - saturation_f) * bwgt);
	float h = ((1.0f - saturation_f) * bwgt);
	float i = ((1.0f - saturation_f) * bwgt + saturation_f);

	CCM_temp[0] = a * (float) ccm[0] + d * (float) ccm[3] + g * (float) ccm[6];
	CCM_temp[1] = a * (float) ccm[1] + d * (float) ccm[4] + g * (float) ccm[7];
	CCM_temp[2] = a * (float) ccm[2] + d * (float) ccm[5] + g * (float) ccm[8];
	CCM_temp[3] = b * (float) ccm[0] + e * (float) ccm[3] + h * (float) ccm[6];
	CCM_temp[4] = b * (float) ccm[1] + e * (float) ccm[4] + h * (float) ccm[7];
	CCM_temp[5] = b * (float) ccm[2] + e * (float) ccm[5] + h * (float) ccm[8];
	CCM_temp[6] = c * (float) ccm[0] + f * (float) ccm[3] + i * (float) ccm[6];
	CCM_temp[7] = c * (float) ccm[1] + f * (float) ccm[4] + i * (float) ccm[7];
	CCM_temp[8] = c * (float) ccm[2] + f * (float) ccm[5] + i * (float) ccm[8];

	ccm[0] = CCM_temp[0];
	ccm[1] = CCM_temp[1];
	ccm[2] = CCM_temp[2];
	ccm[3] = CCM_temp[3];
	ccm[4] = CCM_temp[4];
	ccm[5] = CCM_temp[5];
	ccm[6] = CCM_temp[6];
	ccm[7] = CCM_temp[7];
	ccm[8] = CCM_temp[8];

	pContext->saturation_set = 0;
	return;
}

void auto_white_balance(video_ipipe_t *pContext) {

	Xint32 i, round;
	Xint32 DAY_error, CWF_error;
	Xint32 U30_error, INC_error;
	Xint32 DAY_d, CWF_d;
	Xint32 U30_d, INC_d;

	float DAY_p, CWF_p, U30_p, INC_p;
	float DAY_s, CWF_s, U30_s, INC_s;
	float den, f;
	Xint32 *CCM_RGB_DAY_ptr;
	Xint32 *CCM_RGB_CWF_ptr;
	Xint32 *CCM_RGB_U30_ptr;
	Xint32 *CCM_RGB_INC_ptr;

	CCM_RGB_DAY_ptr = (Xint32*) &CCM_RGB_DAY;
	CCM_RGB_CWF_ptr = (Xint32*) &CCM_RGB_CWF;
	CCM_RGB_U30_ptr = (Xint32*) &CCM_RGB_U30;
	CCM_RGB_INC_ptr = (Xint32*) &CCM_RGB_INC;
	DAY_error = 1;
	CWF_error = 1;
	U30_error = 1;
	INC_error = 1;

	DAY_d = 0;
	CWF_d = 0;
	U30_d = 0;
	INC_d = 0;
#if 0
	for (i=0; i<256; i++) {
		round = pContext->stats_handler_chroma_hist[i]/1000;
		DAY_d += STATS_ZOOM2_DAY[i]*round;
		CWF_d += STATS_ZOOM2_CWF[i]*round;
		U30_d += STATS_ZOOM2_U30[i]*round;
		INC_d += STATS_ZOOM2_INC[i]*round;
	}
#else
	// Optimization #2
	//    Only correlate STATS_HIST data
	//    with non-zero coefficients
	{
		Xuint32 addr;
		// Correlate with non-zero DAY coefficients
		for (i = 0; i < sizeof(day_nonzero_indexes); i++) {
			addr = (Xuint32) day_nonzero_indexes[i];
			round = pContext->stats_handler_chroma_hist[addr] / 1000;
			DAY_d += STATS_ZOOM2_DAY[addr] * round;
		}
		// Correlate with non-zero CWF coefficients
		for (i = 0; i < sizeof(cwf_nonzero_indexes); i++) {
			addr = (Xuint32) cwf_nonzero_indexes[i];
			round = pContext->stats_handler_chroma_hist[addr] / 1000;
			CWF_d += STATS_ZOOM2_CWF[addr] * round;
		}
		// Correlate with non-zero U30 coefficients
		for (i = 0; i < sizeof(u30_nonzero_indexes); i++) {
			addr = (Xuint32) u30_nonzero_indexes[i];
			round = pContext->stats_handler_chroma_hist[addr] / 1000;
			U30_d += STATS_ZOOM2_U30[addr] * round;
		}
		// Correlate with non-zero INC coefficients
		for (i = 0; i < sizeof(inc_nonzero_indexes); i++) {
			addr = (Xuint32) inc_nonzero_indexes[i];
			round = pContext->stats_handler_chroma_hist[addr] / 1000;
			INC_d += STATS_ZOOM2_INC[addr] * round;
		}
	}
#endif

	DAY_p = (float) DAY_d;
	CWF_p = (float) CWF_d;
	U30_p = (float) U30_d;
	INC_p = (float) INC_d;

	den = DAY_p + CWF_p + U30_p + INC_p;
	DAY_s = DAY_p / den;
	CWF_s = CWF_p / den;
	U30_s = U30_p / den;
	INC_s = INC_p / den;

	DAY_d = 100 * DAY_s;
	CWF_d = 100 * CWF_s;
	U30_d = 100 * U30_s;
	INC_d = 100 * INC_s;
	pContext->stats_handler_awb_metric_day = DAY_d;
	pContext->stats_handler_awb_metric_cwf = CWF_d;
	pContext->stats_handler_awb_metric_u30 = U30_d;
	pContext->stats_handler_awb_metric_inc = INC_d;

	for (i = 0; i < 12; i++) {
		f = CCM_RGB_DAY_ptr[i] * DAY_s;
		f += CCM_RGB_CWF_ptr[i] * CWF_s;
		f += CCM_RGB_INC_ptr[i] * INC_s;
		f += CCM_RGB_U30_ptr[i] * U30_s;
		pContext->ccm[i] = (Xint32) f;
	}

	// add brightness and contrast

	set_contrast(pContext, pContext->ccm);
	set_saturation(pContext, pContext->ccm);
	set_brightness(pContext, pContext->ccm);

	vipp_ccm_setCoefficients(pContext, pContext->ccm);
}

void manual_white_balance(video_ipipe_t *pContext) {
	Xint32 i;
	Xint32 *CCM_ptr;

	switch (pContext->ccm_select) {
	case 0:
		CCM_ptr = (Xint32*) &CCM_IDENTITY;
		break;
	case 1:
		CCM_ptr = (Xint32*) &CCM_RGB_DAY;
		break;
	case 2:
		CCM_ptr = (Xint32*) &CCM_RGB_CWF;
		break;
	case 3:
		CCM_ptr = (Xint32*) &CCM_RGB_U30;
		break;
	case 4:
		CCM_ptr = (Xint32*) &CCM_RGB_INC;
		break;
	}

	for (i = 0; i < 12; i++) {
		pContext->ccm[i] = CCM_ptr[i];
	}

	set_contrast(pContext, pContext->ccm);
	set_saturation(pContext, pContext->ccm);
	set_brightness(pContext, pContext->ccm);

	vipp_ccm_setCoefficients(pContext, pContext->ccm);
}

// This function modularizes exposure adjustments.
// If, in the future exposure bands are defined, all
// adjustments can take place here.
void adjust_exposure(video_ipipe_t *pContext, Xint32 difference) {
#if defined(AUTO_GAIN_BASED_ON_EXPOSURE_STATUS)
	// Pre-scale difference
	Xint32 speed = -10000;
	difference /= speed;
#endif
#if defined(AUTO_GAIN_BASED_ON_TARGET_LEVEL)
	difference = -difference;
#endif

	// Keep a running average (ie. low pass filter) of last 4 differences
	pContext->stats_handler_aec_adjust_lpf -=
			(pContext->stats_handler_aec_adjust_lpf) / 4;
	pContext->stats_handler_aec_adjust_lpf += difference / 4;
	pContext->stats_handler_aec_adjust_inc =
			(pContext->stats_handler_aec_adjust_lpf) / 16;

	// Apply averaged difference
	//OS_PRINTF("[adjust_exposure] difference=%d, lpf=%d, inc=%d\n\r", difference, pContext->stats_handler_aec_adjust_lpf, pContext->stats_handler_aec_adjust_inc );
	//ivk_camera_exposure_config(camera_select, difference);
	if (pContext->fpSensorStepExposure)
		pContext->fpSensorStepExposure(pContext->pSensor,
				pContext->stats_handler_aec_adjust_inc);

}

// This function modularizes exposure adjustments.
// If, in the future exposure bands are defined, all
// adjustments can take place here.
void adjust_gain(video_ipipe_t *pContext, Xint32 difference) {
#if defined(AUTO_GAIN_BASED_ON_EXPOSURE_STATUS)
	// Pre-scale difference
	Xint32 speed = -10000;
	difference /= speed;
#endif
#if defined(AUTO_GAIN_BASED_ON_TARGET_LEVEL)
	difference = -difference;
#endif

	// Keep a running average (ie. low pass filter) of last 16 differences
	pContext->stats_handler_agc_adjust_lpf -=
			(pContext->stats_handler_agc_adjust_lpf) / 16;
	pContext->stats_handler_agc_adjust_lpf += difference / 16;
	pContext->stats_handler_agc_adjust_inc =
			(pContext->stats_handler_agc_adjust_lpf) / 4;

	// Apply averaged difference
	//OS_PRINTF("[adjust_gain] difference=%d, lpf=%d, inc=%d\n\r", difference, pContext->stats_handler_agc_adjust_lpf, pContext->stats_handler_agc_adjust_inc );
	//ivk_camera_gain_config(camera_select, difference);
	if (pContext->fpSensorStepGain)
		pContext->fpSensorStepGain(pContext->pSensor,
				pContext->stats_handler_agc_adjust_inc);

}

// This function sets the sensor integration
// time according to measured y_hist values
void auto_gain_exposure(video_ipipe_t *pContext) {
	int i, gain, exposure;
	Xint32 lo_25percent;
	Xint32 mid_50percent;
	Xint32 hi_25percent;
	Xint32 sum = 0;

	lo_25percent = pContext->stats_handler_luma_metric_lo;
	mid_50percent = pContext->stats_handler_luma_metric_mid;
	hi_25percent = pContext->stats_handler_luma_metric_hi;

	pContext->stats_handler_aec_adjust_inc = 0; // until proven otherwise
	pContext->stats_handler_agc_adjust_inc = 0; // until proven otherwise

// Auto-Gain/Exposure based on Average Intensity
#if defined(AUTO_GAIN_BASED_ON_TARGET_LEVEL)
	if (pContext->auto_exp_en) {
		if (pContext->average_level > (pContext->target_level + 10)) {
			adjust_exposure(pContext,
					(pContext->average_level - pContext->target_level));
		}
		if ((pContext->average_level + 10) < pContext->target_level) {
			adjust_exposure(pContext,
					(pContext->average_level - pContext->target_level));
		}
	}
	if (pContext->auto_gain_en) {
		if (pContext->average_level > (pContext->target_level + 10)) {
			adjust_gain(pContext,
					(pContext->average_level - pContext->target_level));
		}
		if ((pContext->average_level + 10) < pContext->target_level) {
			adjust_gain(pContext,
					(pContext->average_level - pContext->target_level));
		}
	}
#endif // #if defined(AUTO_GAIN_BASED_ON_TARGET_LEVEL)
// Auto-Gain/Exposure based on Under/Over-Exposure Status
#if defined(AUTO_GAIN_BASED_ON_EXPOSURE_STATUS)

	if (pContext->auto_exp_en)
	{
		if (pContext->auto_gain_en)
		{	// Both Auto Exposure and Auto Gain enabled

			//gain = ivk_camera_get_gain(camera_select);
			if ( pContext->fpSensorGetGain )
			pContext->fpSensorGetGain( pContext->pSensor, &gain );
			else
			gain = 128;// default value (?)
			//exposure = ivk_camera_get_exposure(camera_select);
			if ( pContext->fpSensorGetExposure )
			pContext->fpSensorGetExposure( pContext->pSensor, &exposure );
			else
			//exposure = 1000; // default value
			exposure = 90;// default value
//			OS_PRINTF("exposure=%3d, gain=%3d\r\n", exposure, gain);
			//if ((gain>2) && (exposure<0x2FF)) { // Try to trade off gain for exposure
			//	adjust_exposure(pContext,-exposure*1000);
			//	adjust_gain(pContext,-gain*1000);
			//} else
			{
				//if (hi_25percent*2>mid_50percent)  {	// Overexposed
				if ( pContext->stats_handler_exp_metric_over ) {
					adjust_gain(pContext,hi_25percent-lo_25percent);
					if (gain<2)
					adjust_exposure(pContext,hi_25percent - lo_25percent);
				}

				//if (lo_25percent*2>mid_50percent)  {		// Underexposed
				if ( pContext->stats_handler_exp_metric_under ) {
					adjust_exposure(pContext,hi_25percent - lo_25percent);
					//if (exposure>1000)
					if (exposure>90)
					adjust_gain(pContext,hi_25percent - lo_25percent);
				}
			}
		}
		else	// Auto Exposure Control only
		{
			//if (hi_25percent*2>mid_50percent)
			if ( pContext->stats_handler_exp_metric_over )
			adjust_exposure(pContext,hi_25percent - lo_25percent);// Overexposed
			//if (lo_25percent*2>mid_50percent)
			if ( pContext->stats_handler_exp_metric_under )
			adjust_exposure(pContext,hi_25percent - lo_25percent);// Underexposed
		}
	}
	else		// Auto Gain Control only
	{
		//if (hi_25percent*2>mid_50percent)
		if ( pContext->stats_handler_exp_metric_over )
		adjust_gain(pContext,hi_25percent - lo_25percent);// Overexposed
		//if (lo_25percent*2>mid_50percent)
		if ( pContext->stats_handler_exp_metric_under )
		adjust_gain(pContext,hi_25percent - lo_25percent);// Underexposed
	}
#endif // #if defined(AUTO_GAIN_BASED_ON_EXPOSURE_STATUS)
}

// This function equalizes the y histogram and
// uses it to write to the gamma tables

void gamma_equalization(video_ipipe_t *pContext) {
	int i;
	Xuint32 addr, data;
	Xuint32 equalized_hist[STATS_HIST_DEPTH];
	Xuint16 normalized_hist[STATS_HIST_DEPTH];

	// check if stats core has loaded new data
	// lum_data_valid acts as a semaphore between
	// the interrupt data write and this functions
	// data read.

	Xuint32 sum = 0;

	// integrate over y_hist
	// note: overwrites y_hist currently
	for (i = 1; i < STATS_HIST_DEPTH; i++) {
		sum += y_hist[i];
		equalized_hist[i] = sum;
	}
	// sanity check
	if (sum == 0) {
		return;
	}

	float tmp;
	// control strength of equalization
	//pContext->gamma_eq_str = 1.0;

	for (i = 0; i < STATS_HIST_DEPTH; i++) {  // equalize y_hist
		//tmp = equalized_hist[i] * 255.49 / sum;
		tmp = equalized_hist[i] * ((float) STATS_HIST_DEPTH - 0.51) / sum;
		normalized_hist[i] = (Xuint16) (pContext->gamma_eq_str * tmp
				+ (1.0 - pContext->gamma_eq_str) * i);
	}

	// write new values to gamma
#if defined(XPAR_GAMMA_0_BASEADDR)
	GAMMA_RegUpdateEnable(pContext->uBaseAddr_GAMMA);
	for (addr = 0; addr < STATS_HIST_DEPTH; addr++) {
		// Apply normalized histogram uniformly to each color channel
		data = normalized_hist[addr];
		GAMMA_WriteReg(pContext->uBaseAddr_GAMMA, GAMMA_ADDR_DATA,
				((addr+(0*STATS_HIST_DEPTH)) << 16) + data); // Red   LUT
		GAMMA_WriteReg(pContext->uBaseAddr_GAMMA, GAMMA_ADDR_DATA,
				((addr+(1*STATS_HIST_DEPTH)) << 16) + data); // Blue  LUT
		GAMMA_WriteReg(pContext->uBaseAddr_GAMMA, GAMMA_ADDR_DATA,
				((addr+(2*STATS_HIST_DEPTH)) << 16) + data); // Green LUT
	}
	GAMMA_RegUpdateDisable(pContext->uBaseAddr_GAMMA);
#endif

	// release semaphore
	//pContext->lum_data_valid = 0;
}

#include "fmc_imageon_demo.h"
extern fmc_imageon_demo_t fmc_imageon_demo;

#if defined(LINUX_CODE)
void *vipp_stats_handler(void* p) {
	video_ipipe_t *pContext = (video_ipipe_t *) p;
	int color, i;
	int r, c;
	Xint32 lo_25percent;
	Xint32 mid_50percent;
	Xint32 hi_25percent;
	Xint32 sum;
	Xuint32 average_intensity;

	pContext->stats_handler_active = 1;
	//OS_PRINTF("[vipp_stats_handler] ... started\n\r" );

	while (!pContext->stats_handler_stop) {
		//if ( pContext->bVerbose )
		//{
		//   OS_PRINTF("[vipp_stats_handler] ... heartbeat\n\r" );
		//}
		//sleep(1);

		{
			int timeout = 99;

			pthread_mutex_lock(&(pContext->stats_handler_mutex)); // Enter critical section
			{
				Stats_ClrStatusSet(pContext->uBaseAddr_STATS);
				Stats_ClrStatusUnset(pContext->uBaseAddr_STATS);
				Stats_ReadoutEnable(pContext->uBaseAddr_STATS);
			}
			pthread_mutex_unlock(&(pContext->stats_handler_mutex)); // Exit critical section

			millisleep(15);

			// poll DONE status flag
			while (!(Stats_DONE_Status( pContext->uBaseAddr_STATS ) | 0x00000002)
					&& (--timeout))
				;
			if (!timeout) {
				OS_PRINTF(
						"[vipp_stats_handler] ERROR : Timeout waiting for DONE Frame acquisition complete!\n\r");
				return NULL ;
			}

			pthread_mutex_lock(&(pContext->stats_handler_mutex)); // Enter critical section
			{
				millisleep(15);

				// Interrupt Routine code

				pContext->stats_handler_frame_cnt++;

				// Get luma histogram
				stats_get_lum_hist(pContext->uBaseAddr_STATS);
				sum = 0;
				for (i = 0; i < STATS_HIST_DEPTH; i++) {
					sum += y_hist[i];
					if (i == (STATS_HIST_DEPTH * 0.25))
						lo_25percent = sum;
					if (i == (STATS_HIST_DEPTH * 0.75))
						mid_50percent = sum;
				}
				hi_25percent = sum - mid_50percent;
				mid_50percent = mid_50percent - lo_25percent;

				if (sum == 2073600) // sanity check (sum should be 1920*1080)
						{
					// Get Y histogram
					for (i = 0; i < STATS_HIST_DEPTH; i++) {
						pContext->stats_handler_luma_hist[i] = y_hist[i];
					}
					// Calculate average intensity
					average_intensity = 0;
					for (i = 0; i < STATS_HIST_DEPTH; i++) {
						average_intensity += i * y_hist[i];
					}
#if STATS_DATA_WIDTH == 8
					average_intensity = average_intensity << 2; // normalize to 10bits
#endif
					average_intensity = average_intensity / 2073600;
					pContext->average_level = average_intensity;
					// Save intensity statistics
					pContext->stats_handler_luma_metric_lo = lo_25percent;
					pContext->stats_handler_luma_metric_mid = mid_50percent;
					pContext->stats_handler_luma_metric_hi = hi_25percent;
					pContext->stats_handler_exp_metric_over =
							(((Xuint32) (hi_25percent
									* (pContext->exp_factor_over)))
									> mid_50percent) ? 1 : 0;
					pContext->stats_handler_exp_metric_under =
							(((Xuint32) (lo_25percent
									* (pContext->exp_factor_under)))
									> mid_50percent) ? 1 : 0;

					// Get R/G/B histograms
					stats_get_rgb_hist(pContext->uBaseAddr_STATS);
					pContext->stats_handler_rgb_saturated[0] = 0;
					pContext->stats_handler_rgb_saturated[1] = 0;
					pContext->stats_handler_rgb_saturated[2] = 0;
					for (i = 0; i < STATS_HIST_DEPTH; i++) {
						pContext->stats_handler_rgb_hist[0][i] = r_hist[i];
						pContext->stats_handler_rgb_hist[1][i] = g_hist[i];
						pContext->stats_handler_rgb_hist[2][i] = b_hist[i];
						// Check for saturation in each color channel
						//    consider saturated if there are values in top 5%
						if (i > (STATS_HIST_DEPTH * 0.75)) {
							if (r_hist[i] > 0)
								pContext->stats_handler_rgb_saturated[0] = 1;
							if (g_hist[i] > 0)
								pContext->stats_handler_rgb_saturated[1] = 1;
							if (b_hist[i] > 0)
								pContext->stats_handler_rgb_saturated[2] = 1;
						}
					}
					// Get average values for r/g/b
					stats_get_sum(pContext->uBaseAddr_STATS);
					for (color = 0; color < 3; color++) {
						pContext->stats_handler_rgb_mean[color] = 0;
						for (i = 0; i < 16; i++) {
							pContext->stats_handler_rgb_mean[color] +=
									sum_lo[i][color];
						}
					}
					// Get chroma histogram
					stats_get_chrom_hist(pContext->uBaseAddr_STATS);
#if STATS_HIST_DEPTH == 1024
					// Cr-Cb histogram is 32x32,
					// keep center 16x16 portion for auto white balance algorithm
					for ( r = 0; r < 16; r++ )
					{
						for ( c = 0; c < 16; c++ )
						{

							pContext->stats_handler_chroma_hist[((r)*16)+(c)] = cc_hist[((r+8)*32)+(c+8)];
						}
					}
#else
					// Cr-Cb histogram is 16x16,
					// keep "as is" for auto white balance algorithm
					for (i = 0; i < STATS_HIST_DEPTH; i++) {
						pContext->stats_handler_chroma_hist[i] = cc_hist[i];
					}
#endif

					if ((pContext->auto_exp_en) || (pContext->auto_gain_en)) {
						auto_gain_exposure(pContext);
					}

					if (pContext->gamma_eq_en) {
						gamma_equalization(pContext);
					}

					if (pContext->auto_wb_en) {
						auto_white_balance(pContext);
					} else {
						manual_white_balance(pContext);
					}

					if (pContext->bVerbose) {
						Xuint32 sensor_gain;
						Xuint32 sensor_exposure;
						pContext->fpSensorGetGain(pContext->pSensor,
								&sensor_gain);
						pContext->fpSensorGetExposure(pContext->pSensor,
								&sensor_exposure);

						OS_PRINTF("[vipp_stats_handler] ");
						//OS_PRINTF( "frames=%6d ", pContext->stats_handler_frame_cnt );
						OS_PRINTF("luminance={%7d,%7d,%7d} ",
								pContext->stats_handler_luma_metric_lo,
								pContext->stats_handler_luma_metric_mid,
								pContext->stats_handler_luma_metric_hi);
						OS_PRINTF("exposure=%s ",
								pContext->stats_handler_exp_metric_over ?
										"over  " :
								pContext->stats_handler_exp_metric_under ?
										"under " : "ok    ");
						if (pContext->auto_exp_en) {
							OS_PRINTF("aec=on  (  %+4d => %4d) ",
									pContext->stats_handler_aec_adjust_inc,
									sensor_exposure);
						} else {
							OS_PRINTF("aec=off (manual => %4d) ",
									fmc_imageon_demo.vita_exposure);
						}
						if (pContext->auto_gain_en) {
							OS_PRINTF("agc=on  (  %+4d => %4d) ",
									pContext->stats_handler_agc_adjust_inc,
									sensor_gain);
						} else {
							OS_PRINTF("agc=off (manual => %4d) ",
									fmc_imageon_demo.vita_dgain);
						}
						if (pContext->auto_wb_en) {
							OS_PRINTF("awb={%2d,%2d,%2d,%2d} ",
									pContext->stats_handler_awb_metric_day,
									pContext->stats_handler_awb_metric_cwf,
									pContext->stats_handler_awb_metric_u30,
									pContext->stats_handler_awb_metric_inc);
						} else {
							OS_PRINTF("awb={    off    } ");
						}
						OS_PRINTF("\r\n");
						millisleep(100); // add delay to slow down display rate
					} // if ( pContext->bVerbose )

				} // if ( sum == 2073600 ) // sanity check (sum should be 1920*1080)
				else {
					//OS_PRINTF( "[vipp_stats_handler] ERROR : Histogram total %d (expected %d)\n\r", sum, 2073600 );
				}

				Stats_ReadoutDisable(pContext->uBaseAddr_STATS);

			}
			pthread_mutex_unlock(&(pContext->stats_handler_mutex)); // Exit critical section

		}

	}

	pContext->stats_handler_active = 0;
	//OS_PRINTF("[vipp_stats_handler] ... stopped\n\r" );

	return NULL ;
}
#endif

#if 0

void vipp_stats_handler(void* p)
{
	video_ipipe_t *pContext = (video_ipipe_t *)p;

	// Acknowledge and clear interrupt
	Stats_ClrStatusSet( pContext->uBaseAddr_STATS );

	XIntc_Acknowledge(&intc_dev, XPAR_MICROBLAZE_0_INTC_STATS_0_IRQ_INTR);

	pContext->stats_handler_frame_cnt++;
	if ( !(pContext->stats_handler_frame_cnt % 30) )
	{
		OS_PRINTF( "\r[STATS] frames=%6d ", pContext->stats_handler_frame_cnt );
		OS_PRINTF( "awb={%2d,%2d,%2d,%2d} ",
				pContext->stats_handler_awb_metric_day,
				pContext->stats_handler_awb_metric_cwf,
				pContext->stats_handler_awb_metric_u30,
				pContext->stats_handler_awb_metric_inc );
		OS_PRINTF( "luminance={%6d,%6d,%6d} ",
				pContext->stats_handler_luma_metric_lo ,
				pContext->stats_handler_luma_metric_mid,
				pContext->stats_handler_luma_metric_hi );
		OS_PRINTF( "exposure=%s ",
				pContext->stats_handler_exp_metric_over ? "over  " :
				pContext->stats_handler_exp_metric_under ? "under " :
				"ok    " );
		OS_PRINTF( "aec=%4d ", pContext->stats_handler_aec_metric_exp );
		OS_PRINTF( "agc=%4d ", pContext->stats_handler_agc_metric_gain );
	}

	if ((gamma_eq_en) || (auto_gain_en)|| (auto_exp_en))
	{
		stats_get_lum_hist( pContext->uBaseAddr_STATS );
	}

	if ((auto_exp_en) || (auto_gain_en))
	{
		auto_gain_exposure( pContext );
	}

	if (gamma_eq_en)
	{
		gamma_equalization( pContext );
	}

	if (auto_wb_en)
	{
#if 0
		stats_get_chrom_hist( pContext->uBaseAddr_STATS );
#else
		// Optimization #1
		//    Only read STATS_HIST data that will be
		//    correlated with non-zero coefficients
		{
			int i;
			Xuint32 addr;
			// clear table
			for (addr = 0; addr < STATS_HIST_DEPTH; ++addr)
			{
				cc_hist[addr] = 0;
			}
			for ( i = 0; i < sizeof(stats_readout_indexes); i++ )
			{
				addr = (Xuint32)stats_readout_indexes[i];
				Stats_WriteReg( pContext->uBaseAddr_STATS, STATS_REG_HIST_ADDR, addr);
				cc_hist[addr] = stats_read_data_reg( pContext->uBaseAddr_STATS, STATS_REG_CCHIST);
			}
		}
#endif

		auto_white_balance( pContext );
	}

	// Set Stats core to re-acquire data
	Stats_ReadoutDisable( pContext->uBaseAddr_STATS );
	// Then return into readout mode once finished
	Stats_ReadoutEnable( pContext->uBaseAddr_STATS );
	// Allow Status Reg to update again
	Stats_ClrStatusUnset( pContext->uBaseAddr_STATS );
}

void vipp_interrupt_init( video_ipipe_t *pContext )
{
	int i;

	pContext->stats_handler_frame_cnt = 0;
	pContext->stats_handler_awb_metric_day = 0;
	pContext->stats_handler_awb_metric_cwf = 0;
	pContext->stats_handler_awb_metric_u30 = 0;
	pContext->stats_handler_awb_metric_inc = 0;
	for ( i = 0; i < STATS_HIST_DEPTH; i++ )
	{
		pContext->stats_handler_luma_hist[i] = 0;
	}
	for ( i = 0; i < STATS_HIST_DEPTH; i++ )
	{
		pContext->stats_handler_rgb_hist[0][i] = 0;
		pContext->stats_handler_rgb_hist[1][i] = 0;
		pContext->stats_handler_rgb_hist[2][i] = 0;
	}
	for ( i = 0; i < 3; i++ )
	{
		pContext->stats_handler_rgb_saturated[i] = 0;
		pContext->stats_handler_rgb_mean[i] = 0;
	}
	for ( i = 0; i < 256; i++ )
	{
		pContext->stats_handler_chroma_hist[i] = 0;
	}
	pContext->stats_handler_luma_metric_lo = 0;
	pContext->stats_handler_luma_metric_mid = 0;
	pContext->stats_handler_luma_metric_hi = 0;
	pContext->stats_handler_exp_metric_over = 0;
	pContext->stats_handler_exp_metric_under = 0;
	pContext->stats_handler_aec_metric_exp = 0;
	pContext->stats_handler_agc_metric_gain = 0;

#if 0 // this is performed by platform.c\platform_setup_interrupts()
	// initialize XIntc
	XIntc_Initialize(&intc_dev, XPAR_INTC_0_DEVICE_ID);

	// setup stats interrupt in Intc
	XIntc_Connect(&intc_dev, XPAR_MICROBLAZE_0_INTC_STATS_0_IRQ_INTR,
			(XInterruptHandler) vipp_stats_handler, NULL);

	microblaze_register_handler((XInterruptHandler) XIntc_DeviceInterruptHandler, XPAR_INTC_0_DEVICE_ID);
	microblaze_enable_interrupts();

	// start interrupt controller
	XIntc_Start(&intc_dev, XIN_REAL_MODE);
#endif

	// initialize statistics interrupts
	// enable global and DONE stats interrupts

	Stats_WriteReg( pContext->uBaseAddr_STATS, STATS_REG_03_IRQ_CONTROL, STATS_DONE_IRQ_MASK | STATS_IRQ_MASK);

	// start data acquisition
	Stats_ClrStatusSet( pContext->uBaseAddr_STATS );
	Stats_ReadoutEnable( pContext->uBaseAddr_STATS );
	Stats_ClrStatusUnset( pContext->uBaseAddr_STATS );
#if 0 // this is performed by platform.c\platform_setup_interrupts()
	XIntc_Enable(&intc_dev, XPAR_MICROBLAZE_0_INTC_STATS_0_IRQ_INTR);
#endif
	print("Statistics interrupts enabled\n\r");
}
#endif
